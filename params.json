{"name":"CollectionFS","tagline":"Meteor filesystem based on gridFS, Meteor.collections and filehandlers","body":"#CollectionFS\r\nIs a simple way of handling files on the web in the Meteor environment\r\n\r\nHave a look at [Live example](http://collectionfs.meteor.com/)\r\n\r\nIt's work in progress, I'll take pull requests, feature requests and feedback for optimizing stability and speed\r\n\r\nCollectionFS is a mix of both Meteor.Collection and GridFS mongoDB.\r\nUsing Meteor and gridFS principles we get:\r\n* Security handling\r\n* Handling sharing\r\n* Restrictions eg. only allow certain content types, fields, users etc.\r\n* Reactive data, the collectionFS's methods should all be reactive\r\n* Ability for the user to resume upload after connection loss, browser crash or cola in keyboard\r\n* At the moment files are loaded into the client as Blob universal way of handling large binary data\r\n* Create multiple cached versions, sizes or formats of your files and get an url to the file - or upload files to another service / server\r\n\r\nDesign overview:\r\n```js\r\n        App               <-| Can retrieve files via DDP and HTTP\r\n-------->|\r\n|      __|________        <-| Adds a connection for each CollectionFS\r\n|      |     | | |\r\n*******************       <-| Internet \r\n|      |     | | |\r\n|      |     | | |--- 1.  <-| DDP Connections dedicated CollectionFS\r\n|   Meteor   | |----- 2.  <-| for up/downloading chunks / binary data\r\n|   (DDP)    #              | Using EJSON for transport wrapper of\r\n|      |     |------- n.  <-| $binary data\r\n|      |     #####\r\n|      |       |\r\n|      Mongodb-|<- Server <-| Server can add files pr. auto\r\n|      (gridFS)             | or on request from client\r\n|          |\r\n|          |_______##     <-| Filehandlers running autonom scanning\r\n|                   |       | new files to handle, new filehandlers,\r\n|                   |       | retries failed ones *default 1 worker*\r\n|                   |\r\n|--- Remote files <-|     <-| Filehandlers specified by the user\r\n|--- Local files  <-|       | transform / handle uploaded files. \r\n       (http)               | Eg. Uploading to remote services,\r\n                            | resizing images, converting sound,\r\n                            | video, generating tts or just making\r\n                            | cached versions of db files to the\r\n                            | filesystem.\r\n```\r\n\r\n##How to use?\r\n\r\n####1. Install:\r\n```\r\n    mrt add collectionFS\r\n```\r\n*Requires `Meteorite` get it at [atmosphere.meteor.com](https://atmosphere.meteor.com)*\r\n\r\n####2. Create model: [client, server]\r\n```js\r\n    ContactsFS = new CollectionFS('contacts');\r\n```\r\n*You can still create a `Contacts = new Meteor.Collection('contacts')` since gridFS maps on eg. `contacts.files` and `contacts.chunks`*\r\n\r\n####3. Adding security in model: [client, server]\r\n*Only needed when using `accounts-...` (eg. removed the `insecure` package)*\r\n```js\r\n    ContactsFS.allow({\r\n      insert: function(userId, myFile) { return userId && myFile.owner === userId; },\r\n      update: function(userId, files, fields, modifier) {\r\n            return _.all(files, function (myFile) {\r\n              return (userId == myFile.owner);\r\n\r\n        });  //EO interate through files\r\n      },\r\n      remove: function(userId, files) { return false; }\r\n    });\r\n```\r\n*The collectionFS supports functions `.allow`, `.deny`, `.find`, `findOne` used when subscribing/ publishing from server* \r\n*It's here you can add restrictions eg. on content-types, filesizes etc.*\r\n*`.update`, `.remove` are also supported, `remove` removes all chunks and files related to the file removed*\r\n\r\n\r\n####4. Disabling autopublish: \r\n*If you would rather not autopublish all files, you can turn off the autopublish option.  This is useful if you want to limit the number of published documents or the fields that get published*\r\n\r\n#####Disabling autopublish: [client, server]\r\n```js\r\n  ContactsFS = new CollectionFS('contacts', { autopublish: false });\r\n```\r\n#####Example [server]\r\n```js\r\n    // Disable autopublish\r\n    ContactsFS = new CollectionFS('contacts', { autopublish: false });\r\n\r\n    // example #1 - manually publish with an optional param\r\n    Meteor.publish('listContactsFiles', function(filter) {\r\n      // sort by handedAt time and only return the filename, handledAt and _id fields\r\n      return ContactsFS.find({ complete: filter.completed }, {\r\n              sort:{ handledAt: 1 }, \r\n              fields: { _id: 1, filename: 1, handledAt: 1},\r\n              limit: filter.limit\r\n      })\r\n    });\r\n\r\n    // example #2 - limit results and only show users files they own\r\n    Meteor.publish('myContactsFiles', function() {\r\n      if (this.userId) {\r\n        return ContactsFS.find({ owner: this.userId }, { limit: 30 });\r\n      }\r\n    });    \r\n```\r\n*Note: It's possible to set one more option serverside: `ContactsFS = new CollectionFS('contacts', { maxFilehandlers: 1 });` - This will set max simultane filehandlers in total on the server, dispite collection*\r\n\r\n#####Example [client]\r\n```js\r\n    // Disable autopublish / autosubscribe\r\n    ContactsFS = new CollectionFS('contacts', { autopublish: false});\r\n\r\n    // example #1 - manually subscribe and show completed only \r\n    // (goes with example #1 above)\r\n\r\n    // Use session for setting filter options\r\n    Session.setDefault('myFilter', { completed: true, limit: 30 });\r\n\r\n    // Make subscription depend on the current filter\r\n    Deps.autorun(function() {\r\n      var filter = Session.get('myFilter');\r\n      Meteor.subscribe('listContactsFiles', filter);\r\n    });\r\n```\r\n\r\n##Uploading file\r\n####1. Adding the view:\r\n```html\r\n    <template name=\"queControl\">\r\n      <h3>Select file(s) to upload:</h3>\r\n      <input name=\"files\" type=\"file\" class=\"fileUploader\" multiple>\r\n    </template>\r\n```\r\n\r\n####2. Adding the controller: [client]\r\n```js\r\n    Template.queControl.events({\r\n      'change .fileUploader': function (e) {\r\n         var files = e.target.files;\r\n         for (var i = 0, f; f = files[i]; i++) {\r\n           ContactsFS.storeFile(f);\r\n         }\r\n      }\r\n    });\r\n```\r\n*ContactsFS.storeFile(f) returns fileId or null, actual downloads are spawned as \"threads\". It's possible to add metadata: `storeFile(file, {})` - callback or eventlisteners are on the todo*\r\n\r\n##Downloading file\r\n####1. Adding the view:\r\n```html\r\n    <template name=\"fileTable\">\r\n      {{#each Files}}\r\n        <a class=\"btn btn-primary btn-mini btnFileSaveAs\">Save as</a>{{filename}}<br/>\r\n      {{else}}\r\n        No files uploaded\r\n      {{/each}}\r\n    </template>\r\n```\r\n\r\n####2. Adding the controller: [client]\r\n```js\r\n    Template.fileTable.events({\r\n      'click .btnFileSaveAs': function() {\r\n        ContactsFS.retrieveBlob(this._id, function(fileItem) {\r\n          if (fileItem.blob)\r\n            saveAs(fileItem.blob, fileItem.filename)\r\n          else\r\n            saveAs(fileItem.file, fileItem.filename);\r\n        });\r\n      } //EO saveAs\r\n    });\r\n```\r\n*In future only a blob will be returned, this will return local file if available. The `Save as` calls the Filesaver.js by Eli Grey, http://eligrey.com - It doesn't work on iPad*\r\n\r\n####3. Adding controller helper: [client]\r\n```js\r\n    Template.fileTable.helpers({\r\n      Files: function() {\r\n        return ContactsFS.find({}, { sort: { uploadDate:-1 } });\r\n      }\r\n    });\r\n```\r\n*There are some in the works for `widgets` / `components` eg. gui elements for uploading files, ex. via drag & drop*\r\n\r\n####4. Store a file serverside\r\n```js\r\nvar myText = 'Hello world, I wrote this..:)';\r\nvar buffer = Buffer(myText.length);\r\n\r\nfor (var i = 0; i < myText.length; i++)\r\n  buffer[i] = myText.charCodeAt(i);\r\n\r\nContactsFS.storeBuffer('My server uploaded file.txt', buffer, { \r\n  // Set a contentType (optional)\r\n  contentType: 'text/plain',\r\n  // Set a user id (optional)\r\n  owner: 'WAaPHfyfgHGaeJ5kK',\r\n  // Stop live update of progress (optional default to false)     \r\n  noProgress: true,\r\n  // Attach custom data to the file  \r\n  metadata: { text: 'some stuff' }\r\n});\r\n```\r\n*A rough example to illustrate the api*\r\n\r\n####5. Retrieve a file serverside\r\n```js\r\nvar blob = ContactsFS.retrieveBuffer(fileId); // Returns a Buffer\r\n\r\n// Get additional info from the file record\r\nvar fileRecord = ContactsFS.findOne(fileId);\r\n```\r\n\r\n###Create server cache/versions of files and get an url reference\r\nFilehandlers are serverside functions that makes caching versions easier. The functions are run and handled a file record and a blob / ```Buffer``` containing all the bytes.\r\n* Return a blob and it gets named, saved and put in database while the user can continue. When files are created the files are updated containing link to the new file - all done reactivly live.\r\n* If only custom metadata is returned without a blob / Buffer then no files saved but metadata is saved in database.\r\n* If null returned then only filehandler name and a date is saved in database.\r\n* If false returned the filehandler failed and it will be resumed later\r\n\r\n####Options\r\n*Each filehandler is handed a options object*\r\n```js\r\noptions: {\r\n  blob,              // Type of node.js Buffer() \r\n  fileRecord: {\r\n    chunkSize : self.chunkSize, // Default 256kb ~ 262.144 bytes\r\n    uploadDate : Date.now(),  // Client set date\r\n    handledAt: null,          // datetime set by Server when handled\r\n    fileHandler:{},           // fileHandler supplied data if any\r\n    md5 : null,               // Not yet implemented\r\n    complete : false,         // countChunks == numChunks\r\n    currentChunk: -1,         // Used to coordinate clients\r\n    owner: Meteor.userId(),\r\n    countChunks: countChunks, // Expected number of chunks\r\n    numChunks: 0,             // number of chunks in database\r\n    filename : file.name,     // Original filename\r\n    length: ''+file.size,     // Issue in Meteor\r\n    contentType : file.type,\r\n    metadata : (options) ? options : null,  // Custom data\r\n    /* TODO:\r\n    startedAt: null,          // Start timer for upload start\r\n    endedAt: null,            // Stop timer for upload ended\r\n    */\r\n  },\r\n  destination: function, // Check below\r\n  sumFailes: 0..3 (times filehandler failed in this recovery session)\r\n}\r\n```\r\n####options.destination - function\r\n*filehandlers are presented with a helper function for handling paths - all paths can be custom, but it's recommended to use those returned by `destination()`*\r\n`options.destination( [extension] )` takes an optional `extension` eg.:\r\n```js\r\n  var dest = options.destination('jpg'); // otherwise orginal extension is used\r\n```\r\nObject returned:\r\n```js\r\n  dest == {\r\n    serverFilename: '/absolute/path/uniqname.jpg', // Unix or windows based\r\n    fileData: {\r\n      url: '/web/url/uniqname.jpg',\r\n      extension: 'jpg'\r\n    }\r\n  }\r\n```\r\nThe `destination` helper gets handy eg. when manually saving an image from within the filehandler.\r\n```js\r\n  Filesystem.fileHandlers({\r\n    soundToWav: function(options) {\r\n      // Manipulate file, convert it to wav\r\n      var dest = options.destination('wav');\r\n      writeFileToDisk(dest.serverFilename, blob);\r\n\r\n      // Save correct reference to database by returning url and extension - but no blob\r\n      return dest.fileData;\r\n    }\r\n  });\r\n```\r\n\r\nMore examples follows, converters are to come:\r\n\r\n```js\r\nFilesystem.fileHandlers({\r\n  default1: function(options) { //Options contains blob and fileRecord - same is expected in return if should be saved on filesytem, can be modified\r\n    console.log('I am handling 1: '+options.fileRecord.filename);\r\n    return { blob: options.blob, fileRecord: options.fileRecord }; //if no blob then save result in fileHandle (added createdAt)\r\n  },\r\n  default2: function(options) {\r\n    if (options.fileRecord.len > 5000000 || options.fileRecord.contentType != 'image/jpeg') //Save som space, only make cache if less than 1Mb\r\n      return null; //Not an error as if returning false, false would be tried again later...\r\n    console.log('I am handling 2: '+options.fileRecord.filename);\r\n    return options; \r\n  },\r\n  size40x40: function(options) {\r\n    return null;\r\n    // Use Future.wrap for handling async\r\n    /*var im = npm.require('imagemagick'); // Add imagemagick package\r\n    im.resize({\r\n                srcData: options.blob,\r\n                width: 40\r\n           });*/\r\n    console.log('I am handling: '+options.fileRecord.filename+' to...');\r\n    return { extension: 'jpg', blob: options.blob, fileRecord: options.fileRecord }; //or just 'options'...\r\n  },\r\n  size100x100gm: function(options) {\r\n    if (options.fileRecord.contentType != 'image/jpeg')\r\n      return null; // jpeg files only  \r\n\r\n    // Use Future.wrap for handling async\r\n    /*\r\n    var dest = options.destination('jpg').serverFilename; // Set optional extension\r\n\r\n    var gm = npm.require('gm'); // GraphicsMagick required need Meteor package\r\n    gm( options.blob, dest).resize(100,100).quality(90).write(dest, function(err) {\r\n        if(err) {\r\n          // console.log 'GraphicsMagick error ' + err;\r\n          return false; \r\n          // False will trigger rerun, could check options.sumFailes\r\n          // if we only want to rerun 2 times (default limit is 3,\r\n          // but sumFailes is reset at server idle + wait period)\r\n        }\r\n        else {\r\n          // console.log 'Finished writing image.';\r\n          return destination('jpg').fileData; // We only return the url for the file, no blob to save since we took care of it\r\n        }\r\n      });\r\n    */\r\n    // I failed to deliver a url for this, but don't try again\r\n    return null;\r\n  }\r\n});\r\n```\r\n*This is brand new on the testbed, future brings easy image handling shortcuts to imagemagic, maybe som sound/video converting and some integration for uploading to eg. google drive, dropbox etc.*\r\n\r\n###Future:\r\n* Handlebar helpers? `{{fileProgress}}`, `{{fileInQue}}` etc.\r\n* Test server side handling image size etc.\r\n* When code hot deploy the que halts, could be tackled in future version of Meteor\r\n* Deviates from gridFS by using string based files.length (Meteor are working on this issue)\r\n* Prepare ability for special version caching options creating converting images, docs, tts, sound, video, remote server upload etc.\r\n* Make Meteor packages for `GraphicsMagick` etc.\r\n\r\n###Notes:\r\n* This is made as `Make it work, make it fast`, well it just got very fast! *need to test if it's actually faster than regular upload*\r\n* No test suite - any good ones for Meteor?\r\n* Current code client side contains relics and will have a makeover one of these days","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}