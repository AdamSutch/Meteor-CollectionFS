{"name":"CollectionFS","tagline":"Meteor filesystem based on gridFS, Meteor.collections and filehandlers","body":"#This is the 0.3.x dev preview!! [![Build Status](https://travis-ci.org/raix/Meteor-CollectionFS.png?branch=master)](https://travis-ci.org/raix/Meteor-CollectionFS) [![Donate](https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=UX67TUAP29SML)\r\nIt's rough on the edges, please checkout the milestones for progress indication.\r\n\r\n## Where can I get the older versions?\r\nAll versions are tagged but might not work with the latest version of Meteor.\r\n\r\nTo use the version 1 of `collectionFS` please tryout [Eric's updated fork](https://github.com/aldeed/Meteor-CollectionFS)\r\n\r\nI'm working hard on the new version, primary focus is on the code at the moment so docs are somewhat limited.\r\n\r\nKind regards Morten\r\n\r\n#CollectionFS\r\nCollectionFS adds simple yet robust file uploading and downloading abilities to your Meteor web app. It is a mix of [Meteor.Collection](http://docs.meteor.com/#meteor_collection) and MongoDB's [GridFS](http://docs.mongodb.org/manual/core/gridfs/). CollectionFS stores files in your MongoDB database but also provides the ability to easily store files on the server filesystem or a remote filesystem.\r\n\r\n##Example\r\nHere is a [live example](http://collectionfs.meteor.com/) of a file manager app implemented using CollectionFS.\r\n\r\n##Examples getting started\r\n* [Drag&drop with one filehandler](https://github.com/mxab/cfsfileurl-example) by __@mxab__\r\n* [Multiple filehandlers](https://github.com/mxab/cfs-multi-filehandler-example) by __@mxab__\r\n* [Filemanager demo](https://github.com/raix/Meteor-cfs-example-filemanager) by __@raix__\r\n\r\n##Features\r\n* Authorizing uploads and downloads based on Meteor user accounts\r\n* Sharing\r\n* Restrictions (e.g., allow only certain content types, fields, users, etc.)\r\n* Reactive methods\r\n* Ability to resume uploads after connection loss, browser crash, or cola in keyboard\r\n* Files are loaded on the client as a BLOB, a universal way of handling large binary data\r\n* Supports custom file handlers that you can use to:\r\n    * create one or more cached files\r\n    * resize images\r\n    * convert files to another format\r\n    * transfer files to another service or server\r\n    * anything else you want to do!\r\n\r\n##Design Overview\r\n```\r\n        App               <-| Can retrieve files via DDP and HTTP\r\n-------->|\r\n|      __|________        <-| Adds a connection for each CollectionFS\r\n|      |     | | |\r\n*******************       <-| Internet \r\n|      |     | | |\r\n|      |     | | |--- 1.  <-| DDP Connections dedicated CollectionFS\r\n|   Meteor   | |----- 2.  <-| for up/downloading chunks / binary data\r\n|   (DDP)    #              | Using EJSON for transport wrapper of\r\n|      |     |------- n.  <-| $binary data\r\n|      |     #####\r\n|      |       |\r\n|      Mongodb-|<- Server <-| Server can add files pr. auto\r\n|      (gridFS)             | or on request from client\r\n|          |\r\n|          |_______##     <-| Filehandlers running autonom scanning\r\n|                   |       | new files to handle, new filehandlers,\r\n|                   |       | retries failed ones *default 1 worker*\r\n|                   |\r\n|--- Remote files <-|     <-| Filehandlers specified by the user\r\n|--- Local files  <-|       | transform / handle uploaded files. \r\n       (http)               | Eg. uploading to remote services,\r\n                            | resizing images, converting sound,\r\n                            | video, generating tts or just making\r\n                            | cached versions of db files to the\r\n                            | filesystem.\r\n```\r\n\r\n##Getting Started\r\n\r\n###Step 1: Add CollectionFS to Your Project\r\nFirst, install Meteorite from [atmosphere.meteor.com](https://atmosphere.meteor.com) if you haven't already. Meteorite is a Meteor package manager that allows you to install many unofficial packages, including CollectionFS.\r\n\r\nThen:\r\n```\r\nmrt add collectionFS\r\n```\r\n\r\n###Step 2: Create a CollectionFS Model (client and server)\r\nIn the client/server Javascript file where you define the data model for your project, add the following line for each collection that needs to store files. In this example, you might be storing documents related to contacts.\r\n```js\r\nContactsFS = new CollectionFS('contacts', { autopublish: false });\r\n```\r\n*Setting `autopublish` to false is not required, but you will usually want to do this to limit the number of published documents or define which fields should be published. If you have removed the `autopublish` Meteor package, you do not need to set this since nothing will be autopublished by default.*\r\n\r\nIt's important to note that CollectionFS extends the collection (in this example, \"contacts\"), creating contacts.files and contacts.chunks. This means that you can also create a normal `Meteor.Collection` with the same name if necessary for your app. For example:\r\n```js\r\nContacts = new Meteor.Collection('contacts');\r\n```\r\n\r\n###Step 3: Configure Authorization (client and server)\r\n*This step is necessary only if you are using one of the `accounts- * ` packages and you have removed the `insecure` package.*\r\n\r\nIn the client/server Javascript file where you define the data model for your project, use the `allow` and `deny` methods to define which users may insert, update, and remove files. This is no different from defining authorization for a normal `Meteor.Collection`.\r\n\r\n```js\r\nContactsFS.allow({\r\n    insert: function(userId, file) { return userId && file.owner === userId; },\r\n    update: function(userId, files, fields, modifier) {\r\n        return _.all(files, function (file) {\r\n            return (userId == file.owner);\r\n        });  //EO iterate through files\r\n    },\r\n    remove: function(userId, files) { return false; }\r\n});\r\n```\r\n\r\nUsing the file object that is passed to the insert function, you can also restrict based on file characteristics like content types and file size. Alternatively, you can use filters for this. (See the following step.)\r\n\r\n###Step 4: Set Up Filters (client and server)\r\n\r\nTo filter uploads to a CollectionFS so that only certain content types or extensions are allowed, you can use `CollectionFS.filter()`. Refer to the API reference for details. Here's an example:\r\n\r\n```js\r\nContactsFS.filter({\r\n    allow: {\r\n        contentTypes: ['image/*']\r\n    }\r\n});\r\n```\r\n\r\n###Step 5: Publish Files\r\nAssuming that you are not autopublishing CollectionFS documents (see step 2), you now need to define which documents and fields should be published to each client.\r\n\r\nIn a server Javascript file, you can write `publish` functions that return the results of `find` or `findOne` calls to determine which files will be visible on each client. Then in a client Javascript file, you can subscribe to those document sets.\r\n\r\n####Simple Example\r\n```js\r\n// in server.js\r\n// limit results and only show users files they own\r\nMeteor.publish('myContactsFiles', function() {\r\n    if (this.userId) {\r\n        return ContactsFS.find({ owner: this.userId }, { limit: 30 });\r\n    }\r\n});\r\n\r\n// in client.js\r\nMeteor.subscribe('myContactsFiles');\r\n```\r\n\r\n####Example With Client Side Filter Rules and Reactivity\r\n```js\r\n// in server.js\r\nMeteor.publish('listContactsFiles', function(filter) {\r\n    return ContactsFS.find({ complete: filter.completed }, { // publish only complete or only incomplete, depending on client setting\r\n        sort:   { handledAt: 1 }, // sort by handledAt time\r\n        fields: { _id: 1, filename: 1, handledAt: 1}, // publish only the filename, handledAt, and _id fields\r\n        limit:  filter.limit // limit the number of files published, depending on client setting\r\n    })\r\n});\r\n\r\n// in client.js\r\n// Use session for setting filter options\r\nSession.setDefault('myFilter', { completed: true, limit: 30 });\r\n\r\n// Subscription will be updated whenever myFilter session value changes\r\nDeps.autorun(function() {\r\n    var filter = Session.get('myFilter');\r\n    Meteor.subscribe('listContactsFiles', filter);\r\n});\r\n```\r\n\r\n##Common Tasks\r\nNow that you have everything set up, you're probably excited to start transferring some files. Here are examples of how to achieve the most common tasks.\r\n\r\n###Upload a File From the Client\r\nFirst, create a new template for the file upload input.\r\n```html\r\n<template name=\"queueControl\">\r\n    <h3>Select file(s) to upload:</h3>\r\n    <input name=\"files\" type=\"file\" class=\"fileUploader\" multiple>\r\n</template>\r\n```\r\nNext, define an event handler that stores the files after the user selects them.\r\n```js\r\nTemplate.queueControl.events({\r\n    'change .fileUploader': function (e) {\r\n        var files = e.target.files;\r\n        for (var i = 0, f; f = files[i]; i++) {\r\n            ContactsFS.storeFile(f);\r\n        }\r\n    }\r\n});\r\n```\r\nor\r\n```js\r\nTemplate.queueControl.events({\r\n    'change .fileUploader': function (e) {\r\n        var files = e.target.files;\r\n        ContactsFS.storeFiles(files);\r\n    }\r\n});\r\n```\r\n`storeFile` returns immediately with a fileId, or with null if there was a problem. The actual uploads are handled by pseudo-threads. When an upload finishes, client templates that list files or file information are updated live through reactivity.\r\n\r\n`storeFiles` is a convenience method for storing multiple files at once and returns an array of fileIds.\r\n\r\nIf you want to store additional metadata for each file, provide the data in the second parameter.\r\n```js\r\nstoreFile(file, {\r\n   name: \"My File\"\r\n})\r\n```\r\n\r\nThere are currently no available callbacks or event listeners for the upload process. These will be added in a future release.\r\n\r\n###Download a File to the Client\r\nFirst, create a new template for the file link.\r\n```html\r\n<template name=\"fileTable\">\r\n    {{#each files}}\r\n    {{cfsDownloadButton \"ContactsFS\" class=\"btn btn-primary btn-mini\" content=filename}}\r\n    {{else}}\r\n    No files uploaded.\r\n    {{/each}}\r\n</template>\r\n```\r\nNext, provide the data context.\r\n```js\r\n//in client.js\r\nTemplate.fileTable.files = function() {\r\n    //show all files that have been published to the client, with most recently uploaded first\r\n    return ContactsFS.find({}, { sort: { uploadDate:-1 } });\r\n};\r\n```\r\nAnd that's it! The button is created by the helper and wired up\r\nwith the necessary click event to begin downloading the file to the browser.\r\n\r\nFor saving, the helper uses [FileSaver.js](https://github.com/eligrey/FileSaver.js) by [Eli Grey](http://eligrey.com). It doesn't work on iPad.\r\nIf you prefer, you can call `CollectionFS.retrieveBlob()` yourself and use your own saving method with the result.\r\n\r\n###Delete a File\r\nYou can call `remove` on the client or server to remove all chunks and versions related to the original file from the database.\r\n```js\r\nContactsFS.remove(fileId);\r\n```\r\n\r\n###Store a File From the Server\r\nYou can also store files from the server side. You could, for example, retrieve a file from some external URL and save it to your database. Here is a rough example to illustrate:\r\n```js\r\nvar myText = 'Hello world, I wrote this..:)';\r\nvar buffer = Buffer(myText.length);\r\n\r\nfor (var i = 0; i < myText.length; i++) {\r\n    buffer[i] = myText.charCodeAt(i);\r\n}\r\n\r\nContactsFS.storeBuffer('serverFile.txt', buffer, { \r\n    // Set a contentType (optional)\r\n    contentType: 'text/plain',\r\n    // Set a user id (optional)\r\n    owner: 'WAaPHfyfgHGaeJ5kK',\r\n    // Stop live update of progress (optional, defaults to false)     \r\n    noProgress: true,\r\n    // Attach custom data to the file  \r\n    metadata: { text: 'some stuff' },\r\n    // Set encoding (optional default 'utf-8')\r\n    encoding: 'utf-8'\r\n});\r\n```\r\n\r\n###Retrieve a File From the Server\r\nYou can also retrieve files from the server side. \r\n```js\r\n// Get the file itself as a BLOB (Buffer)\r\nvar blob = ContactsFS.retrieveBuffer(fileId);\r\n\r\n// Get additional info from the file record\r\nvar fileRecord = ContactsFS.findOne(fileId);\r\n```\r\n\r\n##Common API Reference\r\n\r\nThe following Meteor.Collection methods are supported, and work identically:\r\n* `find()`\r\n* `findOne()`\r\n* `update()`\r\n* `remove()`\r\n* `allow()`\r\n* `deny()`\r\n\r\nInstead of `insert()`, use `storeFile()` or `storeFiles()`.\r\n\r\n###CollectionFS.filter(filter)\r\n* **filter**: (Required) An object defining file content types and/or extensions that should be allowed or denied, and optionally a maximum file size in bytes.\r\n\r\nCall this in a common javascript file. This is the format of the `filter` object:\r\n\r\n```js\r\n{\r\n    allow: {\r\n        extensions: [],\r\n        contentTypes: []\r\n    },\r\n    deny: {\r\n        extensions: [],\r\n        contentTypes: []\r\n    },\r\n    maxSize: 1048576\r\n}\r\n```\r\n\r\nYou can mix and match filtering based on extension or content types.\r\nThe contentTypes array also supports \"image/*\" and \"audio/*\" and \"video/*\" like\r\nthe \"accepts\" attribute on the HTML5 file input element. `storeFile()` and \r\n`storeFiles()` automatically check each file against these rules before uploading\r\nit, or you can call `CollectionFS.fileIsAllowed()`, passing in a file record object,\r\nif you need to check a file yourself.\r\n\r\nIf a file extension or content type matches any of those listed in `allow`, it is allowed. If not,\r\nit is denied. If it matches both `allow` and `deny`, it is denied. Typically, you would\r\nuse only `allow` or only `deny`, but not both. If you do not call `filter()`, all files are allowed,\r\nas long as they pass the tests in `allow()` and `deny()`.\r\n\r\nThe file extensions must be specified without a leading period.\r\n\r\n###Invalid Event (client or server)\r\n\r\nYou can define a function to be called whenever an \"invalid\" event is dispatched. This happens when a file fails the validation check defined\r\nby `CollectionFS.filter`.\r\n\r\nThis function should accept two arguments:\r\n* **type**: One of the enums in CFSErrorType, depending on which check the file failed.\r\n* **fileRecord**: The fileRecord object.\r\n\r\nTypically you might use this on the client to display an error message to the user, or on the server to log the failure.\r\n\r\nFor example:\r\n\r\n```javascript\r\nSongs.events({\r\n  'invalid': function(type, fileRecord) {\r\n    if (type === CFSErrorType.disallowedContentType || type === CFSErrorType.disallowedExtension) {\r\n      console.log(\"Sorry, \" + fileRecord.filename + \" is not the type of file we're looking for.\");\r\n    } else if (type === CFSErrorType.maxFileSizeExceeded) {\r\n      console.log(\"Sorry, \" + fileRecord.filename + \" is too big to upload.\");\r\n    }\r\n  } \r\n});\r\n```\r\n\r\n##Client API Reference\r\n\r\n###CollectionFS.storeFile(file, metadata)\r\n* **file**: (Required) The browser filehandle.\r\n* **metadata**: An object with any custom data you want to save in the file record for later use.\r\n\r\n`storeFile` returns immediately with a fileId, or with null if there was a problem. The actual uploads are handled by pseudo-threads.\r\n\r\n###CollectionFS.storeFiles(files, metadata, callback)\r\n* **files**: (Required) The browser files array.\r\n* **metadata**: (Optional) An object with any custom data you want to save in the file record for later use, or a function that accepts one parameter, the file object, and returns the metadata object.\r\n* **callback**: (Optional) A function to be called after storing each file when looping over the files. This callback is passed two parameters, `file`, which is the browser file object, and `fileId`, which is the CollectionFS ID for that file.\r\n\r\n`storeFiles` returns immediately with an array of fileIds, or with null if there was a problem. The actual uploads are handled by pseudo-threads. This is a convenience function for calling `storeFile` multiple times; however, if you need to store metadata with each file, you will have to do the looping yourself and use `storeFile`.\r\n\r\n###CollectionFS.retrieveBlob(fileId, callback)\r\n* **fileId**: (Required) The ID of the file\r\n* **callback**: (Required) A function to handle the file BLOB after it's downloaded.\r\n\r\n`callback` is passed one argument, `fileItem`, which is a container for the file. Either fileItem.blob or fileItem.file will be available. fileItem.file is used if the file is already stored locally. In the future, this will be improved so that fileItem.blob is always set.\r\n\r\n`fileItem` also has properties _id, countChunks, and length.\r\n\r\n###CollectionFS.acceptDropsOn(templateName, selector, metadata, callback)\r\n* **templateName**: (Required) The template in which the element that should accept file drops can be found.\r\n* **selector**: (Required) The CSS selector that matches the element that should accept file drops.\r\n* **metadata**: (Optional) Same as the `CollectionFS.storeFiles` metadata argument. Passed to `CollectionFS.storeFiles` for the files that are dropped. Can be a getter function.\r\n* **callback**: (Optional) Same as the `CollectionFS.storeFiles` callback argument. Passed to `CollectionFS.storeFiles` for the files that are dropped.\r\n\r\nSets up all of the elements matching `selector` to support dropping of one or more files onto them. As files are dropped onto these elements, they are automatically stored in the CollectionFS with the given metadata, and then the callback is called for each one.\r\n\r\nFor example:\r\n\r\n```html\r\n<template name=\"audioList\">\r\n   <div class=\"audioList\">\r\n      {{#if cfsHasFiles \"Songs\"}}\r\n      <table>\r\n         <thead>\r\n            <th>ID</th>\r\n            <th>Size</th>\r\n            <th>Filename</th>\r\n            <th>Content type</th>\r\n            <th>Owner</th>\r\n         </thead>\r\n         <tbody>\r\n            {{#each cfsFiles \"Songs\"}}\r\n            {{> song}}\r\n            {{/each}}\r\n         </tbody>\r\n      </table>\r\n      {{else}}\r\n      <div>You have not added any audio files.</div>\r\n      {{/if}}\r\n   </div>\r\n</template>\r\n```\r\n\r\n```js\r\nSongs = new CollectionFS(\"songs\", {autopublish: false});\r\nif (Meteor.isClient) {\r\n  Songs.acceptDropsOn(\"audioList\", \".audioList\");\r\n}\r\n```\r\n\r\n####Example of a metadata getter function:\r\n```js\r\n  Songs.acceptDropsOn('audioList', '.audioList',\r\n    // Metadata getter\r\n    function(event, temp) {\r\n      // This function would be run with `this` from the template\r\n      // it would return the metadata containing the `audioListItemId`\r\n      return { audioListItemId: this._id }\r\n    }\r\n  );\r\n```\r\n\r\n##Server API Reference\r\n\r\n###CollectionFS.storeBuffer(fileName, buffer, options)\r\n* **fileName**: (Required) The name of the file\r\n* **buffer**: (Required) The bufferred content of the file\r\n* **options**: All of these are optional.\r\n    * **contentType**: The content (MIME) type of the file\r\n    * **owner**: The user ID of the user who owns the document   \r\n    * **noProgress**: `true` to prevent live updating of progress; default is `false`\r\n    * **metadata**: An object containing any custom metadata you want to store with the file\r\n    * **encoding**: The file encoding; default is `utf-8`\r\n\r\n###CollectionFS.retrieveBuffer(fileId)\r\n* **fileId**: (Required) The ID of the file\r\nReturns a buffer.\r\n\r\n##Filehandlers\r\nFilehandlers are custom server-side functions that take a file record and a BLOB and do something with them. You can use them to convert files to other formats, process and convert images, store copies of the file on the filesystem, or upload files to remote services.\r\n\r\n###Defining Filehandlers\r\nTo define a filehandler, use the `fileHandlers` function.\r\n```js\r\n  Filesystem.fileHandlers({\r\n    fileHandler1: function(options) {\r\n      //manipulate the file, save to disk, etc.\r\n      return something;\r\n    }\r\n  });\r\n```\r\n###Possible Return Values\r\nDepending on what the filehandler is doing, you can return different values.\r\n* If you return a BLOB: It is named, saved, and stored in database while the user can continue. After the file is successfully stored, the client data and template is updated live.\r\n* If you return metadata without a BLOB: The metadata is saved in the database without the file data.\r\n* If you return a String, it will be used as the URL for that document (usefull if you generated your own file -- see file handlers examples with ImageMagick)\r\n* If you return null: Only the filehandler name and a date is saved in the database.\r\n* If you return false: This means the filehandler failed temporarily. It will be tried again later.\r\n\r\n###Options\r\nEach filehandler should accept one `options` argument. This contains the file data, information about the file, a `destination` helper function, and more.\r\n```js\r\noptions: {\r\n    blob,              // Type of node.js Buffer() \r\n    fileRecord: {\r\n        chunkSize : self.chunkSize, // Default 256kb ~ 262.144 bytes\r\n        uploadDate : Date.now(),  // Client set date\r\n        handledAt: null,          // datetime set by Server when handled\r\n        fileHandler:{},           // fileHandler supplied data if any\r\n        md5 : null,               // Not yet implemented\r\n        complete : false,         // countChunks == numChunks\r\n        currentChunk: -1,         // Used to coordinate clients\r\n        owner: Meteor.userId(),\r\n        countChunks: countChunks, // Expected number of chunks\r\n        numChunks: 0,             // number of chunks in database\r\n        filename : file.name,     // Original filename\r\n        length: ''+file.size,     // Issue in Meteor\r\n        contentType : file.type,\r\n        encoding: encoding,       // Default 'utf-8'\r\n        metadata : (options) ? options : null,  // Custom data\r\n    },\r\n    destination: function,\r\n    sumFailes: 0..3 (times filehandler failed in this recovery session)\r\n}\r\n```\r\n####options.destination(extension)\r\nThis function returns the correct file path for saving the current file to the local filesystem. While you can use custom paths to store files, it's easiest and safest to use the path returned by this function.\r\n\r\nIf you want the file path to use a file extension that is different from the original file extension, pass the optional `extension` argument to `options.destination()`. For example:\r\n```js\r\nvar dest = options.destination('jpg');\r\n```\r\nIn this example, dest might be returned as\r\n```js\r\ndest = {\r\n    serverFilename: '/absolute/path/uniquename.jpg', // Unix or Windows is supported\r\n    fileData: {\r\n        url: '/web/url/uniquename.jpg',\r\n        extension: 'jpg'\r\n    }\r\n}\r\n```\r\n\r\n###Limiting Filehandlers\r\nWhen defining your CollectionFS collection, you can optionally specify the maximum number of simultaneous file handlers you want on the server, in total, regardless of the number of collections.\r\n```js\r\nContactsFS = new CollectionFS('contacts', { maxFilehandlers: 1 });\r\n```\r\n\r\n###Filehandler Examples\r\n\r\n```js\r\nFilesystem.fileHandlers({\r\n  default1: function(options) { // Options contains blob and fileRecord — same is expected in return if should be saved on filesytem, can be modified\r\n    console.log('I am handling default1: ' + options.fileRecord.filename);\r\n    return { blob: options.blob, fileRecord: options.fileRecord }; // if no blob then save result in fileHandle (added createdAt)\r\n  },\r\n  default2: function(options) {\r\n    if (options.fileRecord.len > 5000000 || options.fileRecord.contentType != 'image/jpeg') //Save some space, only make cache if less than 5MB\r\n      return null; // Not an error as if returning false, false would be tried again later...\r\n    console.log('I am handling default2: ' + options.fileRecord.filename);\r\n    return options; \r\n  },\r\n  size40x40: function(options) {\r\n    //... Test that it's an actual image...\r\n    \r\n    // Uses meteorite package imagemagick.\r\n    var destination = options.destination();\r\n    Imagemagick.resize({\r\n       srcData: options.blob,\r\n       dstPath: destination.serverFilename, // Imagemagick will create the file for us.\r\n       width: 40,\r\n       height: 40\r\n    });\r\n    console.log('I am handling: ' + options.fileRecord.filename + ' to '. destination.serverFilename);\r\n    \r\n    // Return the url\r\n    return destination.fileData;\r\n  },\r\n  size100x100gm: function(options) {\r\n    if (options.fileRecord.contentType != 'image/jpeg')\r\n      return null; // jpeg files only  \r\n\r\n    // Use Future.wrap for handling async\r\n    /*\r\n    var dest = options.destination('jpg').serverFilename; // Set optional extension\r\n\r\n    var gm = Npm.require('gm'); // GraphicsMagick required need Meteor package\r\n    gm(options.blob, dest).resize(100,100).quality(90).write(dest, function(err) {\r\n        if (err) {\r\n          // console.log('GraphicsMagick error ' + err);\r\n          return false; \r\n          // False will trigger rerun, could check options.sumFailes\r\n          // if we only want to rerun 2 times (default limit is 3,\r\n          // but sumFailes is reset at server idle + wait period)\r\n        }\r\n        else {\r\n          // console.log('Finished writing image.');\r\n          return destination('jpg').fileData; // We only return the url for the file, no blob to save since we took care of it\r\n        }\r\n      });\r\n    */\r\n    // I failed to deliver a url for this, but don't try again\r\n    return null;\r\n  },\r\n  soundToWav: function(options) {\r\n    // Manipulate file, convert it to wav\r\n    var dest = options.destination('wav');\r\n    writeFileToDisk(dest.serverFilename, blob);\r\n    \r\n    // Save correct reference to database by returning url and extension — but no blob\r\n    return dest.fileData;\r\n  }\r\n});\r\n```\r\n\r\n##Built-In Handlebars Helpers\r\n\r\nA number of handlebar helpers are available to help you generate UI elements related to the files stored in a CollectionFS.\r\n\r\n###cfsFile\r\n\r\n```js\r\n{{cfsFile \"Collection\" fileId}}\r\n```\r\n\r\nReturns the file object with ID fileId in the \"Collection\" CFS.\r\n\r\n###cfsFiles\r\n\r\n```js\r\n{{cfsFile \"Collection\"}}\r\n```\r\n\r\nReturns a cursor for the CFS. Doesn't support any limiting, sorting, etc. except whatever you're doing in `Meteor.publish()`.\r\n\r\n###cfsHasFiles\r\n\r\n```js\r\n{{#if cfsHasFiles \"Collection\"}}\r\n```\r\n\r\nReturns true if the CFS has any files (as filtered by `Meteor.publish()`).\r\n\r\n###cfsIsUploading\r\n\r\n```js\r\n(1) {{cfsIsUploading \"Collection\"}} (with file as current context)\r\n(2) {{cfsIsUploading \"Collection\" file=file}}\r\n(3) {{cfsIsUploading \"Collection\" fileId=fileId}}\r\n```\r\n\r\nReturns true if the file is currently being uploaded to the specified CFS.\r\n\r\n###cfsIsDownloading\r\n\r\n```js\r\n(1) {{cfsIsDownloading \"Collection\"}} (with file as current context)\r\n(2) {{cfsIsDownloading \"Collection\" file=file}}\r\n(3) {{cfsIsDownloading \"Collection\" fileId=fileId}}\r\n```\r\n\r\nReturns true if the file is currently being downloaded from the specified CFS.\r\n\r\n###cfsIsDownloaded\r\n\r\n```js\r\n(1) {{cfsIsDownloaded \"Collection\"}} (with file as current context)\r\n(2) {{cfsIsDownloaded \"Collection\" file=file}}\r\n(3) {{cfsIsDownloaded \"Collection\" fileId=fileId}}\r\n```\r\n\r\nReturns true if the file has been downloaded from the specified CFS.\r\n\r\n###cfsIsComplete\r\n\r\n```js\r\n(1) {{cfsIsComplete \"Collection\"}} (with file as current context)\r\n(2) {{cfsIsComplete \"Collection\" file=file}}\r\n(3) {{cfsIsComplete \"Collection\" fileId=fileId}}\r\n```\r\n\r\nReturns true whenever neither a download nor an upload is happening for the given file.\r\n\r\n###cfsQueueProgress\r\n\r\n```js\r\n(1) {{cfsQueueProgress \"Collection\"}} (with file as current context)\r\n(2) {{cfsQueueProgress \"Collection\" file=file}}\r\n(3) {{cfsQueueProgress \"Collection\" fileId=fileId}}\r\n```\r\n\r\nReturns the percentage progress of the current operation for the file, either upload or download.\r\n\r\n###cfsQueueProgressBar\r\n\r\n```js\r\n(1) {{cfsQueueProgressBar \"Collection\"}} (with file as current context)\r\n(2) {{cfsQueueProgressBar \"Collection\" file=file}}\r\n(3) {{cfsQueueProgressBar \"Collection\" fileId=fileId}}\r\n```\r\n\r\nCreates an HTML5 `<progress>` element that shows the progress of the current operation for the file, either upload or download.\r\nYou can optionally specify `id` or `class` attributes to help you style it. For example:\r\n\r\n```html\r\n{{#each cfsFiles \"Songs\"}}\r\n{{#if cfsIsUploading \"Songs\"}}\r\n{{cfsQueueProgressBar \"Songs\" class=\"uploadBar\"}}<br/><em>Uploading...</em>\r\n{{/if}}\r\n{{#if cfsIsDownloading \"Songs\"}}\r\n{{cfsQueueProgressBar \"Songs\" class=\"downloadBar\"}}<br/><em>Downloading...</em>\r\n{{/if}}\r\n{{/each}}\r\n```\r\n\r\nOlder browsers will simply display the percentage.\r\n\r\n###cfsIsPaused\r\n\r\n```js\r\n{{cfsIsPaused \"Collection\"}}\r\n```\r\n\r\nReturns true if the queue for the CFS is paused.\r\n\r\n###cfsIsOwner\r\n\r\nIs current user the owner of the file?\r\n\r\n```js\r\n(1) {{cfsIsOwner}} (with file as current context)\r\n(2) {{cfsIsOwner file=file}}\r\n(3) {{cfsIsOwner fileId=fileId collection=\"Collection\"}}\r\n```\r\n\r\nIs user with userId the owner of the file?\r\n\r\n```js\r\n(1) {{cfsIsOwner userId=userId}} (with file as current context)\r\n(2) {{cfsIsOwner file=file userId=userId}}\r\n(3) {{cfsIsOwner fileId=fileId collection=\"Collection\" userId=userId}}\r\n```\r\n\r\n###cfsFormattedSize\r\n\r\n```js\r\n(1) {{cfsFormattedSize formatString=formatString}} (with file as current context)\r\n(2) {{cfsFormattedSize file=file formatString=formatString}}\r\n(3) {{cfsFormattedSize fileId=fileId collection=\"Collection\" formatString=formatString}}\r\n```\r\n\r\nFormats the file size of the given file using any format string supported by numeral.js. If you don't specify formatString,\r\na default format string `'0.00 b'` is used.\r\n\r\n###cfsFileHandlers\r\n\r\n```js\r\n(1) {{cfsFileHandlers}} (with file as current context)\r\n(2) {{cfsFileHandlers file=file}}\r\n(3) {{cfsFileHandlers fileId=fileId collection=\"Collection\"}}\r\n```\r\n\r\nReturns an array of filehandlers for the file, suitable for use with `#each`.\r\n\r\n###cfsFileUrl\r\n\r\n```js\r\n(1) {{cfsFileUrl \"defaultHandler\"}} (with file as current context)\r\n(2) {{cfsFileUrl \"defaultHandler\" file=file}}\r\n(3) {{cfsFileUrl \"defaultHandler\" fileId=fileId collection=\"Collection\"}}\r\n```\r\n\r\nReturns the file URL for the given file, as assigned by the given filehandler.\r\n\r\n###cfsDownloadButton\r\n\r\n```js\r\n(1) {{cfsDownloadButton \"Collection\"}} (with file as current context)\r\n(2) {{cfsDownloadButton \"Collection\" file=file}}\r\n(3) {{cfsDownloadButton \"Collection\" fileId=fileId}}\r\n```\r\n\r\nCreates an HTML `<button>` element for the given file which, when clicked, initiates downloading\r\nof the file by the browser. This uses a FileSaver shim which should support most modern browsers.\r\n\r\nYou can optionally specify `id` or `class` attributes to help you style it, and a `content` attribute\r\nto use as the button element content. If you don't specify content, the button will say \"Download\".\r\n\r\n##Upcoming Features\r\nAn overhaul and many fixes and new features will hopefully be completed by July 2013.\r\n* Test server-side handling of image size, etc.\r\n* When there is a hot code deploy the queue halts, which could be tackled in future version of Meteor.\r\n* CollectionFS deviates from GridFS by using string-based files.length (Meteor are working on this issue).\r\n* Prepare ability for special version caching options creating converting images, docs, tts, sound, video, remote server upload etc.\r\n* Integrated uploads to Google Drive, Dropbox, etc.\r\n* Make Meteor packages for `GraphicsMagick`, etc.\r\n* More options for storing and retrieving data\r\n* More control over the queue eg. trottling the queue\r\n* Make a dropbox like example of client side\r\n* Test suite — any good ones for Meteor?\r\n* Current code client side contains relics and will have a make-over one of these days.\r\n\r\n##Contributing\r\nDo you have ideas, issues, documentation, fixes, or pull requests? Anyone is welcome to help make CollectionFS faster, more versatile, and easier to use.\r\n\r\n###Special Thanks to Code Contributors\r\n__@aldeed, @eprochasson, @emgee3, @nhibner, @mitar, @petrocket__  \r\n*ranked by last commit*\r\n(Are you missing from the list? File it as an issue or submit a pull request.)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}