{"name":"CollectionFS","tagline":"Meteor filesystem based on gridFS, Meteor.collections and filehandlers","body":"#CollectionFS\r\nIs a simple way of handling files on the web in the Meteor environment.\r\n\r\nHave a look at [Live example](http://collectionfs.meteor.com/).\r\n\r\nIt's work in progress, I'll take pull requests, feature requests and feedback for optimizing stability and speed.\r\n\r\nCollectionFS is a mix of both [Meteor.Collection](http://docs.meteor.com/#meteor_collection) and MongoDB's [GridFS](http://docs.mongodb.org/manual/core/gridfs/).\r\n\r\nUsing Meteor and GridFS principles we get:\r\n\r\n* Security\r\n* Sharing\r\n* Restrictions (e.g. only allow certain content types, fields, users, etc.)\r\n* Reactive data — CollectionFS's methods should all be reactive\r\n* Ability to resume uploads after connection loss, browser crash or cola in keyboard\r\n* At the moment, files are loaded into the client as a Blob — a universal way of handling large binary data\r\n* Create multiple cached versions, sizes or formats of your files, with an url to the file — or upload files to another service / server\r\n\r\nDesign overview:\r\n```js\r\n        App               <-| Can retrieve files via DDP and HTTP\r\n-------->|\r\n|      __|________        <-| Adds a connection for each CollectionFS\r\n|      |     | | |\r\n*******************       <-| Internet \r\n|      |     | | |\r\n|      |     | | |--- 1.  <-| DDP Connections dedicated CollectionFS\r\n|   Meteor   | |----- 2.  <-| for up/downloading chunks / binary data\r\n|   (DDP)    #              | Using EJSON for transport wrapper of\r\n|      |     |------- n.  <-| $binary data\r\n|      |     #####\r\n|      |       |\r\n|      Mongodb-|<- Server <-| Server can add files pr. auto\r\n|      (gridFS)             | or on request from client\r\n|          |\r\n|          |_______##     <-| Filehandlers running autonom scanning\r\n|                   |       | new files to handle, new filehandlers,\r\n|                   |       | retries failed ones *default 1 worker*\r\n|                   |\r\n|--- Remote files <-|     <-| Filehandlers specified by the user\r\n|--- Local files  <-|       | transform / handle uploaded files. \r\n       (http)               | Eg. Uploading to remote services,\r\n                            | resizing images, converting sound,\r\n                            | video, generating tts or just making\r\n                            | cached versions of db files to the\r\n                            | filesystem.\r\n```\r\n\r\n##Contributions\r\nDo you have idears, issues, documentation, fixes or pull requests? All is wellcome for making collectionFS faster, more versatile and easier to use.\r\n\r\n###A special thanks and credit goes to code contributors\r\n__@emgee3, @nhibner, @mitar, @petrocket__  \r\n*Ranked by last commit, are you missing from the list? file it as an issue or make a PR :)*\r\n\r\n\r\n##How to use?\r\n\r\n####1. Install:\r\n```\r\n    mrt add collectionFS\r\n```\r\n*Requires `Meteorite` from [atmosphere.meteor.com](https://atmosphere.meteor.com)*\r\n\r\n####2. Create model: [client, server]\r\n```js\r\n    ContactsFS = new CollectionFS('contacts');\r\n```\r\n*You can still create a `Contacts = new Meteor.Collection('contacts')` since GridFS maps on `contacts.files` and `contacts.chunks`*\r\n\r\n####3. Add security to model: [client, server]\r\n*This is only needed when using `accounts-...` and you have removed the `insecure` package.*\r\n```js\r\n    ContactsFS.allow({\r\n      insert: function(userId, myFile) { return userId && myFile.owner === userId; },\r\n      update: function(userId, files, fields, modifier) {\r\n            return _.all(files, function (myFile) {\r\n              return (userId == myFile.owner);\r\n\r\n        });  //EO iterate through files\r\n      },\r\n      remove: function(userId, files) { return false; }\r\n    });\r\n```\r\n*The collectionFS supports functions `.allow`, `.deny`, `.find`, `findOne` used when subscribing/ publishing from server.* \r\n*It's here you can add restrictions, for example allowed content-types, file sizes, etc.*\r\n*`.update`, `.remove` are also supported, `remove` removes all chunks and versions related to the original file.*\r\n\r\n\r\n####4. Disable autopublish: \r\n*If you would rather not autopublish all files, you can turn off the autopublish option. This is useful if you want to limit the number of published documents or the fields that get published.*\r\n\r\n#####Disable autopublish: [client, server]\r\n```js\r\n  ContactsFS = new CollectionFS('contacts', { autopublish: false });\r\n```\r\n#####Example [server]\r\n```js\r\n    // Disable autopublish\r\n    ContactsFS = new CollectionFS('contacts', { autopublish: false });\r\n\r\n    // Example #1 - manually publish with an optional param\r\n    Meteor.publish('listContactsFiles', function(filter) {\r\n      // sort by handledAt time and only return the filename, handledAt and _id fields\r\n      return ContactsFS.find({ complete: filter.completed }, {\r\n              sort:   { handledAt: 1 }, \r\n              fields: { _id: 1, filename: 1, handledAt: 1},\r\n              limit:  filter.limit\r\n      })\r\n    });\r\n\r\n    // Example #2 - limit results and only show users files they own\r\n    Meteor.publish('myContactsFiles', function() {\r\n      if (this.userId) {\r\n        return ContactsFS.find({ owner: this.userId }, { limit: 30 });\r\n      }\r\n    });    \r\n```\r\n*Note: It's possible to set one more option server-side: `ContactsFS = new CollectionFS('contacts', { maxFilehandlers: 1 });`. This will set the maximum simultaneous file handlers on the server, in total, despite number of collections.*\r\n\r\n#####Example [client]\r\n```js\r\n    // Disable autopublish / autosubscribe\r\n    ContactsFS = new CollectionFS('contacts', { autopublish: false});\r\n\r\n    // Example #1 — manually subscribe and show completed only \r\n    // (goes with server example #1 above)\r\n\r\n    // Use session for setting filter options\r\n    Session.setDefault('myFilter', { completed: true, limit: 30 });\r\n\r\n    // Make subscription depend on the current filter\r\n    Deps.autorun(function() {\r\n      var filter = Session.get('myFilter');\r\n      Meteor.subscribe('listContactsFiles', filter);\r\n    });\r\n```\r\n\r\n##Upload files\r\n####1. Adding the view:\r\n```html\r\n    <template name=\"queueControl\">\r\n      <h3>Select file(s) to upload:</h3>\r\n      <input name=\"files\" type=\"file\" class=\"fileUploader\" multiple>\r\n    </template>\r\n```\r\n\r\n####2. Add the controller: [client]\r\n```js\r\n    Template.queueControl.events({\r\n      'change .fileUploader': function (e) {\r\n         var files = e.target.files;\r\n         for (var i = 0, f; f = files[i]; i++) {\r\n           ContactsFS.storeFile(f);\r\n         }\r\n      }\r\n    });\r\n```\r\n*ContactsFS.storeFile(f) returns `fileId` or `null`. Actual downloads are spawned as \"threads\". It's also possible to add metadata: `storeFile(file, {})` — callback or event listeners are on the todo*.\r\n\r\n##Download files\r\n####1. Add the view:\r\n```html\r\n    <template name=\"fileTable\">\r\n      {{#each Files}}\r\n        <a class=\"btn btn-primary btn-mini btnFileSaveAs\">Save as</a>{{filename}}<br/>\r\n      {{else}}\r\n        No files uploaded.\r\n      {{/each}}\r\n    </template>\r\n```\r\n\r\n####2. Add the controller: [client]\r\n```js\r\n    Template.fileTable.events({\r\n      'click .btnFileSaveAs': function() {\r\n        ContactsFS.retrieveBlob(this._id, function(fileItem) {\r\n          if (fileItem.blob) {\r\n            saveAs(fileItem.blob, fileItem.filename);\r\n          } else {\r\n            saveAs(fileItem.file, fileItem.filename);\r\n          }\r\n        });\r\n      } //EO saveAs\r\n    });\r\n```\r\n*In the future only a blob will be returned, this will return local file if available. The `Save as` calls [Filesaver.js](https://github.com/eligrey/FileSaver.js) by [Eli Grey](http://eligrey.com). It doesn't work on iPad.*\r\n\r\n####3. Add controller helper: [client]\r\n```js\r\n    Template.fileTable.helpers({\r\n      Files: function() {\r\n        return ContactsFS.find({}, { sort: { uploadDate:-1 } });\r\n      }\r\n    });\r\n```\r\n*There are some `widgets` / `components` (e.g. gui elements for uploading files, via drag & drop) in the works.*\r\n\r\n##API for storing and retrieving files\r\n\r\n###Client-side\r\n\r\n####Store a file\r\n```js\r\n  Contacts.storeFile(file, metadata);\r\n```\r\n*The file is the browser filehandle, and metadata is custom data to save in the file record for later use*\r\n\r\n####Retrieve a file\r\n```js\r\n  Contacts.retrieveBlob: function(fileId, callback);\r\n```\r\nExample:\r\n```js\r\n  Contacts.retrieveBlob: function(fileId, function(fileItem) {\r\n    // eiter fileItem.blob or fileItem.file is returned (in future a blob should allways be available)\r\n    // fileItem._id\r\n    // fileItem.countChunks\r\n    // fileItem.length   \r\n  });\r\n```\r\n\r\n####TODO:\r\nThe client-side code is going for a rewrite, for a better and more versatile api\r\n* More options for storing and retrieving data\r\n* More control over the queue eg. trottling the queue\r\n* Make a dropbox like example of it\r\n\r\n###Server-side\r\n####Store a file\r\n\r\n```js\r\nvar myText = 'Hello world, I wrote this..:)';\r\nvar buffer = Buffer(myText.length);\r\n\r\nfor (var i = 0; i < myText.length; i++)\r\n  buffer[i] = myText.charCodeAt(i);\r\n\r\nContactsFS.storeBuffer('My server uploaded file.txt', buffer, { \r\n  // Set a contentType (optional)\r\n  contentType: 'text/plain',\r\n  // Set a user id (optional)\r\n  owner: 'WAaPHfyfgHGaeJ5kK',\r\n  // Stop live update of progress (optional, defaults to false)     \r\n  noProgress: true,\r\n  // Attach custom data to the file  \r\n  metadata: { text: 'some stuff' },\r\n  // Set encoding (optional default 'utf-8')\r\n  encoding: 'utf-8'\r\n});\r\n```\r\n*A rough example to illustrate the API.*\r\n\r\n####Retrieve a file server-side\r\n```js\r\nvar blob = ContactsFS.retrieveBuffer(fileId); // Returns a Buffer\r\n\r\n// Get additional info from the file record\r\nvar fileRecord = ContactsFS.findOne(fileId);\r\n```\r\n\r\n##Filehandlers\r\n\r\n###Create cache/versions of files and get an url reference on the server\r\nFilehandlers are server-side functions that makes caching versions easier. The functions are run and handed a file record and a blob / ```Buffer``` containing all the bytes.\r\n\r\n* Return a blob and it gets named, saved and put in database while the user can continue. When files are created the files are updated containing link to the new file — all done reactively live.\r\n* If only custom metadata is returned without a blob / Buffer then no files saved but metadata is saved in database.\r\n* If null returned then only filehandler name and a date is saved in database.\r\n* If false returned the filehandler failed and it will be resumed later\r\n\r\n####Options\r\n*Each filehandler is handed a options object.*\r\n```js\r\noptions: {\r\n  blob,              // Type of node.js Buffer() \r\n  fileRecord: {\r\n    chunkSize : self.chunkSize, // Default 256kb ~ 262.144 bytes\r\n    uploadDate : Date.now(),  // Client set date\r\n    handledAt: null,          // datetime set by Server when handled\r\n    fileHandler:{},           // fileHandler supplied data if any\r\n    md5 : null,               // Not yet implemented\r\n    complete : false,         // countChunks == numChunks\r\n    currentChunk: -1,         // Used to coordinate clients\r\n    owner: Meteor.userId(),\r\n    countChunks: countChunks, // Expected number of chunks\r\n    numChunks: 0,             // number of chunks in database\r\n    filename : file.name,     // Original filename\r\n    length: ''+file.size,     // Issue in Meteor\r\n    contentType : file.type,\r\n    encoding: encoding,       // Default 'utf-8'\r\n    metadata : (options) ? options : null,  // Custom data\r\n    /* TODO:\r\n    startedAt: null,          // Start timer for upload start\r\n    endedAt: null,            // Stop timer for upload ended\r\n    */\r\n  },\r\n  destination: function, // Check below\r\n  sumFailes: 0..3 (times filehandler failed in this recovery session)\r\n}\r\n```\r\n####options.destination - function\r\n*Filehandlers are presented with a helper function for handling paths — all paths can be custom, but it's recommended to use those returned by `destination()`.*\r\n`options.destination( [extension] )` takes an optional `extension` e.g.:\r\n```js\r\n  var dest = options.destination('jpg'); // otherwise original extension is used\r\n```\r\nObject returned:\r\n```js\r\n  dest = {\r\n    serverFilename: '/absolute/path/uniquename.jpg', // Unix or windows based\r\n    fileData: {\r\n      url: '/web/url/uniquename.jpg',\r\n      extension: 'jpg'\r\n    }\r\n  }\r\n```\r\nThe `destination` helper gets handy e.g. when manually saving an image from within the filehandler.\r\n```js\r\n  Filesystem.fileHandlers({\r\n    soundToWav: function(options) {\r\n      // Manipulate file, convert it to wav\r\n      var dest = options.destination('wav');\r\n      writeFileToDisk(dest.serverFilename, blob);\r\n\r\n      // Save correct reference to database by returning url and extension — but no blob\r\n      return dest.fileData;\r\n    }\r\n  });\r\n```\r\n\r\nMore examples follow, converters are to come:\r\n\r\n```js\r\nFilesystem.fileHandlers({\r\n  default1: function(options) { // Options contains blob and fileRecord — same is expected in return if should be saved on filesytem, can be modified\r\n    console.log('I am handling default1: ' + options.fileRecord.filename);\r\n    return { blob: options.blob, fileRecord: options.fileRecord }; // if no blob then save result in fileHandle (added createdAt)\r\n  },\r\n  default2: function(options) {\r\n    if (options.fileRecord.len > 5000000 || options.fileRecord.contentType != 'image/jpeg') //Save some space, only make cache if less than 5MB\r\n      return null; // Not an error as if returning false, false would be tried again later...\r\n    console.log('I am handling default2: ' + options.fileRecord.filename);\r\n    return options; \r\n  },\r\n  size40x40: function(options) {\r\n    return null;\r\n    // Use Future.wrap for handling async\r\n    /* var im = Npm.require('imagemagick'); // Add Imagemagick package\r\n    im.resize({\r\n                srcData: options.blob,\r\n                width: 40\r\n           }); */\r\n    console.log('I am handling: ' + options.fileRecord.filename + ' to...');\r\n    return { extension: 'jpg', blob: options.blob, fileRecord: options.fileRecord }; //or just 'options'...\r\n  },\r\n  size100x100gm: function(options) {\r\n    if (options.fileRecord.contentType != 'image/jpeg')\r\n      return null; // jpeg files only  \r\n\r\n    // Use Future.wrap for handling async\r\n    /*\r\n    var dest = options.destination('jpg').serverFilename; // Set optional extension\r\n\r\n    var gm = Npm.require('gm'); // GraphicsMagick required need Meteor package\r\n    gm(options.blob, dest).resize(100,100).quality(90).write(dest, function(err) {\r\n        if (err) {\r\n          // console.log('GraphicsMagick error ' + err);\r\n          return false; \r\n          // False will trigger rerun, could check options.sumFailes\r\n          // if we only want to rerun 2 times (default limit is 3,\r\n          // but sumFailes is reset at server idle + wait period)\r\n        }\r\n        else {\r\n          // console.log('Finished writing image.');\r\n          return destination('jpg').fileData; // We only return the url for the file, no blob to save since we took care of it\r\n        }\r\n      });\r\n    */\r\n    // I failed to deliver a url for this, but don't try again\r\n    return null;\r\n  }\r\n});\r\n```\r\n*This is brand new on the testbed. The future brings easy image handling shortcuts to Imagemagick and maybe some sound/video conversion and integrated uploads to Google Drive, Dropbox, etc.*\r\n\r\n###Future:\r\n* Handlebar helpers? `{{fileProgress}}`, `{{fileInQue}}` etc.\r\n* Test server-side handling of image size, etc.\r\n* When there is a hot code deploy the queue halts, which could be tackled in future version of Meteor.\r\n* CollectionFS deviates from GridFS by using string-based files.length (Meteor are working on this issue).\r\n* Prepare ability for special version caching options creating converting images, docs, tts, sound, video, remote server upload etc.\r\n* Make Meteor packages for `GraphicsMagick`, etc.\r\n\r\n###Notes:\r\n* This is made as `Make it work, make it fast`, well it just got very fast! *Need to test if it's actually faster than regular upload.*\r\n* No test suite — any good ones for Meteor?\r\n* Current code client side contains relics and will have a make-over one of these days.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}