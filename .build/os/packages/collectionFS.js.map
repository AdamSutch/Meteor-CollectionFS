{"version":3,"file":"/packages/collectionFS.js","sources":["collectionFS/myConsole.js","collectionFS/collectionFS_filesystem.js","collectionFS/collectionFS_server.js","collectionFS/collectionFS_filehandlers.js","collectionFS/collectionFS_server.api.js","collectionFS/collectionFS_server.api.fileobject.js","collectionFS/collectionFS_utillity.js","collectionFS/collectionFS_common.js","collectionFS/collectionFS_common.api.fileobject.js","collectionFS/numeral.js"],"names":[],"mappings":";;;;;;;;AAAA,4E;;AAEA,6C;AACA,uB;AACA,2B;AACA,kB;;AAEA,yB;AACA,6B;AACA,C;;AAEA,kD;;AAEA,iB;AACA,0B;AACA,c;AACA,wB;AACA,iE;AACA,G;AACA,E;AACA,E;;AAEA,6B;;AAEA,+B;AACA,iD;AACA,wB;AACA,Y;AACA,gD;AACA,0C;AACA,2B;AACA,8E;AACA,0C;AACA,gC;AACA,M;AACA,K;AACA,I;;AAEA,W;AACA,gC;AACA,C;;AAEA,+B;;AAEA,sB;;AAEA,W;AACA,0C;AACA,+D;AACA,sB;;AAEA,iB;AACA,uB;AACA,gC;AACA,wE;AACA,G;AACA,I;AACA,C;;;;;;;;;;;;;;;;;;;ACzDA,uE;AACA,iC;AACA,wD;AACA,C;AACA,I;AACA,qB;AACA,kD;AACA,S;AACA,0C;AACA,wE;AACA,I;AACA,W;AACA,8E;AACA,wB;AACA,iC;AACA,iB;AACA,iD;AACA,yC;AACA,6D;AACA,K;AACA,C;AACA,G;;AAEA,qC;AACA,sB;AACA,uD;AACA,C;AACA,iD;;AAEA,oB;AACA,wD;;AAEA,kB;AACA,6B;AACA,gB;AACA,6D;;AAEA,iC;AACA,iC;AACA,iC;AACA,iC;AACA,iC;AACA,iC;AACA,iC;;AAEA,wB;AACA,gB;AACA,kE;AACA,yB;;AAEA,a;AACA,8D;AACA,yB;;AAEA,e;AACA,wE;;AAEA,wD;AACA,4B;AACA,uD;;AAEA,+B;AACA,gC;;AAEA,2C;AACA,gC;AACA,mD;;AAEA,iD;AACA,6E;AACA,E;;;AAGA,2B;AACA,+B;;AAEA,iD;AACA,2C;AACA,wB;AACA,8D;AACA,iC;AACA,uD;AACA,2B;AACA,0E;AACA,2B;AACA,iE;;AAEA,4D;AACA,4D;;AAEA,yE;AACA,qD;AACA,gD;AACA,C;;AAEA,iB;AACA,K;AACA,0C;AACA,uB;;AAEA,K;AACA,2C;AACA,wB;;AAEA,kD;AACA,+C;AACA,0C;AACA,C;;AAEA,iB;AACA,iD;AACA,0C;AACA,yE;AACA,C;;AAEA,sE;;AAEA,iD;AACA,iD;;;;;;;;;;;;;;;;;;;;ACtHA,kB;AACA,gC;AACA,a;AACA,E;AACA,0C;AACA,E;AACA,G;AACA,a;;AAEA,2B;AACA,+B;;AAEA,kC;AACA,yC;AACA,kB;AACA,+B;AACA,sB;AACA,E;;AAEA,uB;AACA,wC;AACA,iB;AACA,mB;AACA,qC;AACA,0D;AACA,8B;AACA,wC;AACA,K;AACA,K;AACA,+B;AACA,4D;AACA,2C;AACA,8D;AACA,sD;AACA,gD;;AAEA,4C;;AAEA,mB;AACA,qC;AACA,oD;AACA,I;AACA,kC;;AAEA,U;AACA,kB;AACA,2B;AACA,2E;AACA,sE;AACA,2B;AACA,0B;AACA,2B;AACA,I;;AAEA,6E;AACA,2D;;AAEA,wC;AACA,iC;AACA,qD;AACA,2B;AACA,wB;AACA,mB;;AAEA,qC;AACA,sC;AACA,4D;AACA,mB;AACA,iB;;AAEA,iC;AACA,4E;AACA,oF;AACA,kE;AACA,M;;AAEA,yC;AACA,qE;;AAEA,wC;AACA,Y;AACA,kD;AACA,wC;AACA,gC;AACA,W;AACA,O;;AAEA,Y;AACA,oB;AACA,kB;AACA,2C;AACA,gC;AACA,M;;AAEA,a;AACA,mB;AACA,wB;;AAEA,4C;AACA,mF;AACA,mB;AACA,iB;AACA,oC;AACA,4E;AACA,mF;AACA,S;;AAEA,W;AACA,mB;AACA,uB;AACA,6B;AACA,8C;AACA,oB;AACA,K;AACA,e;AACA,wB;;AAEA,8D;AACA,oD;AACA,kB;AACA,qD;;AAEA,mB;AACA,4C;AACA,4B;AACA,iE;AACA,4D;AACA,2D;AACA,oD;AACA,oC;AACA,qC;AACA,kB;AACA,Y;AACA,sC;AACA,2C;AACA,8C;AACA,M;AACA,K;AACA,sD;AACA,W;AACA,mC;AACA,oE;AACA,O;AACA,U;AACA,yB;AACA,gE;AACA,G;AACA,wB;;AAEA,sC;AACA,4B;;AAEA,oD;AACA,8B;AACA,2C;AACA,sE;AACA,wB;AACA,gD;;AAEA,yB;AACA,iD;AACA,gC;AACA,oE;AACA,0B;AACA,wD;AACA,a;AACA,8D;AACA,0D;AACA,8C;AACA,mE;AACA,4E;AACA,8E;AACA,4D;AACA,+C;AACA,iD;AACA,qD;AACA,wC;AACA,sD;AACA,yB;AACA,wC;AACA,kD;AACA,4C;AACA,oC;AACA,+B;AACA,4B;AACA,uC;AACA,yB;AACA,wB;;AAEA,e;;AAEA,oB;;AAEA,qC;AACA,iB;AACA,mB;AACA,E;;;;;;;;;;;;;;;;;;;ACpMA,8B;AACA,E;AACA,S;AACA,iE;AACA,oB;AACA,+E;AACA,e;AACA,0E;AACA,+E;AACA,uE;AACA,Y;AACA,2E;AACA,2B;AACA,E;AACA,Y;AACA,8B;AACA,0B;AACA,iD;AACA,mB;AACA,O;AACA,oB;AACA,+C;AACA,6E;AACA,oB;AACA,Q;AACA,8B;AACA,gD;AACA,+E;AACA,oB;AACA,Q;AACA,E;AACA,M;AACA,E;AACA,U;AACA,mE;AACA,gC;AACA,kE;AACA,6C;AACA,sD;AACA,sD;AACA,+B;AACA,yE;AACA,qC;AACA,E;AACA,U;AACA,uE;AACA,mE;AACA,E;;AAEA,2C;;AAEA,a;;AAEA,2B;AACA,+B;;AAEA,iC;AACA,qD;AACA,2E;;;AAGA,2D;AACA,wD;AACA,oC;AACA,M;AACA,oD;AACA,uC;AACA,M;AACA,mD;AACA,iC;AACA,K;AACA,G;AACA,G;;AAEA,yC;AACA,iB;AACA,kC;;AAEA,oC;AACA,uD;AACA,mD;AACA,+E;;AAEA,uC;AACA,kC;AACA,G;;AAEA,uD;;AAEA,gB;AACA,+E;;AAEA,oB;;AAEA,oC;AACA,yB;AACA,kB;AACA,wD;AACA,0B;AACA,yC;AACA,8C;AACA,6D;AACA,8B;;AAEA,8C;AACA,kE;AACA,6E;;AAEA,wE;AACA,+B;AACA,4B;AACA,oD;AACA,4C;AACA,6B;AACA,wD;AACA,W;AACA,4D;AACA,uB;AACA,+C;AACA,uC;AACA,yD;AACA,4B;AACA,6D;AACA,iD;AACA,O;;AAEA,kD;AACA,qD;AACA,sE;AACA,gE;AACA,8E;AACA,a;AACA,yC;;AAEA,4C;AACA,uB;AACA,+C;AACA,uC;AACA,yD;AACA,4B;AACA,wE;AACA,oD;AACA,gE;AACA,iD;AACA,O;;AAEA,0E;AACA,6C;AACA,qD;AACA,sE;AACA,mE;AACA,a;AACA,M;;AAEA,iC;AACA,sB;;AAEA,iC;AACA,iC;AACA,kD;AACA,kB;AACA,+C;AACA,uD;AACA,a;AACA,oB;AACA,4D;AACA,a;AACA,0E;AACA,uC;AACA,6C;AACA,sE;AACA,qE;AACA,0C;AACA,4B;AACA,mE;AACA,+E;AACA,4C;AACA,uC;AACA,0C;AACA,kE;AACA,4C;AACA,wE;AACA,gD;AACA,uD;AACA,oD;AACA,iB;AACA,0B;AACA,+C;AACA,gC;;AAEA,8B;AACA,uB;;AAEA,iD;AACA,8D;AACA,+E;AACA,S;AACA,W;AACA,mE;AACA,8D;AACA,4E;AACA,8B;AACA,S;AACA,I;AACA,kC;AACA,mB;;AAEA,uD;AACA,kB;;AAEA,gB;AACA,8D;;AAEA,qB;AACA,gC;AACA,iD;AACA,mC;AACA,qC;AACA,qD;AACA,8C;;AAEA,sE;AACA,wC;AACA,qD;AACA,wD;AACA,0E;AACA,+B;AACA,6B;AACA,wE;;AAEA,mD;AACA,iE;AACA,e;AACA,2E;AACA,sE;AACA,gB;AACA,qE;AACA,sD;AACA,+C;AACA,oE;AACA,qC;AACA,qE;AACA,wD;AACA,mD;AACA,oD;AACA,qE;AACA,qE;AACA,sE;AACA,mC;AACA,kD;;AAEA,c;AACA,8D;AACA,kB;AACA,mB;AACA,0C;AACA,Q;AACA,Q;AACA,yB;;AAEA,mE;AACA,+C;AACA,yE;AACA,sB;AACA,yD;AACA,sB;AACA,2D;AACA,yD;AACA,oB;AACA,O;;AAEA,6B;AACA,U;AACA,8C;AACA,mC;AACA,qC;AACA,yB;AACA,uC;AACA,kC;AACA,e;AACA,iB;AACA,+D;AACA,4C;AACA,M;;AAEA,0E;AACA,0B;AACA,wB;AACA,6C;;AAEA,qE;AACA,mC;;AAEA,iC;AACA,yE;AACA,iE;AACA,wC;AACA,iE;AACA,uB;AACA,e;AACA,kE;AACA,oC;AACA,iE;AACA,wC;AACA,2E;AACA,uB;;AAEA,gD;AACA,2D;AACA,Q;;AAEA,c;;AAEA,sD;AACA,gE;AACA,+C;AACA,sB;;AAEA,oB;AACA,kE;AACA,4B;;AAEA,oE;AACA,gE;AACA,uC;AACA,sB;;AAEA,0E;;AAEA,uE;AACA,gE;AACA,kE;AACA,sB;;AAEA,+B;AACA,qB;;AAEA,qD;AACA,4C;AACA,c;AACA,8B;AACA,2D;AACA,iD;AACA,yB;AACA,2C;AACA,4D;AACA,4D;AACA,8D;AACA,E;AACA,4B;;;;;;;;;;;;;;;;;;;;AC7VA,a;;AAEA,kC;AACA,mD;;AAEA,mB;AACA,+C;AACA,wD;AACA,2C;AACA,K;;AAEA,iB;AACA,qC;AACA,2E;AACA,K;;AAEA,kB;AACA,oB;;AAEA,0B;AACA,4E;;AAEA,iC;AACA,c;AACA,kB;AACA,uB;AACA,sB;AACA,oE;AACA,wD;AACA,I;AACA,uE;;AAEA,4B;AACA,mE;;AAEA,qC;AACA,yC;;AAEA,yB;AACA,gB;AACA,wE;AACA,+B;AACA,K;;AAEA,8B;AACA,oD;;AAEA,uB;AACA,mE;AACA,uE;;AAEA,mC;AACA,iC;AACA,2E;AACA,iE;AACA,8D;AACA,M;;AAEA,4B;AACA,c;AACA,+E;AACA,0B;AACA,O;;AAEA,gF;AACA,oD;AACA,iD;AACA,oD;AACA,0B;AACA,yB;AACA,sD;AACA,a;AACA,O;AACA,yB;;AAEA,qC;AACA,gB;AACA,qB;;AAEA,mC;AACA,gB;AACA,uE;AACA,K;AACA,4B;AACA,kB;;AAEA,yB;AACA,uD;AACA,oB;AACA,2E;AACA,K;AACA,0C;AACA,qD;AACA,0D;AACA,gE;AACA,a;AACA,K;AACA,8D;AACA,mD;AACA,uE;;AAEA,qB;AACA,+D;;AAEA,gB;AACA,4C;;AAEA,8B;AACA,uE;;AAEA,I;AACA,4B;AACA,0D;AACA,+B;AACA,qC;AACA,O;AACA,U;AACA,2B;;AAEA,iB;;AAEA,qD;AACA,gC;AACA,uB;AACA,6C;AACA,2D;AACA,sD;AACA,O;;AAEA,uD;AACA,iC;AACA,8D;AACA,6C;AACA,U;AACA,mC;AACA,gD;AACA,0E;AACA,8D;AACA,6C;AACA,O;AACA,sB;;AAEA,c;AACA,uB;AACA,G;;AAEA,wC;AACA,oC;AACA,8C;AACA,G;AACA,4B;AACA,qB;;AAEA,E;AACA,G;;;;;;;;;;;;;;;;;;;AC1JA,a;;AAEA,E;AACA,Y;;AAEA,6D;AACA,wE;AACA,sC;AACA,2E;AACA,2E;AACA,+B;;AAEA,E;AACA,iC;AACA,qD;AACA,2E;;AAEA,qC;AACA,sB;AACA,6B;AACA,I;AACA,4B;AACA,kB;AACA,4B;AACA,qB;AACA,I;AACA,iC;AACA,uB;AACA,sC;AACA,0B;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;AC/BA,a;;AAEA,mB;AACA,kD;AACA,mC;AACA,wC;AACA,+C;AACA,E;;AAEA,iD;AACA,8B;AACA,kD;AACA,0C;AACA,mC;AACA,mB;AACA,Y;AACA,K;AACA,wE;AACA,mB;AACA,Y;AACA,K;AACA,wE;AACA,mB;AACA,Y;AACA,K;AACA,wE;AACA,mB;AACA,Y;AACA,K;AACA,G;AACA,e;AACA,E;;AAEA,0C;AACA,gB;AACA,sC;AACA,qC;AACA,iB;AACA,G;AACA,6B;AACA,wC;AACA,a;AACA,G;AACA,wB;AACA,2B;AACA,uB;AACA,8B;AACA,0C;AACA,e;AACA,K;AACA,wB;AACA,4E;AACA,oB;AACA,K;AACA,mB;AACA,G;AACA,iE;AACA,E;;AAEA,wB;AACA,sD;AACA,uB;AACA,qC;AACA,sE;AACA,E;AACA,E;AACA,2C;AACA,mB;AACA,sB;AACA,C;AACA,E;;AAEA,gE;AACA,+B;AACA,6C;AACA,wC;AACA,E;;AAEA,6C;AACA,uB;AACA,qC;AACA,gC;AACA,E;;AAEA,+B;AACA,yC;AACA,oB;AACA,E;;;;;;;;;;;;;;;;;;;ACvFA,a;;AAEA,uD;AACA,kC;AACA,mB;AACA,wD;AACA,I;AACA,sB;AACA,2D;AACA,I;AACA,qB;AACA,0D;AACA,I;AACA,qB;AACA,0D;AACA,I;AACA,oB;AACA,yD;AACA,I;AACA,mB;AACA,wD;AACA,I;AACA,kC;AACA,0C;AACA,I;AACA,6B;AACA,mC;AACA,+D;AACA,yB;AACA,K;AACA,6D;AACA,wB;AACA,K;AACA,2D;AACA,8B;AACA,K;AACA,4E;AACA,oC;AACA,K;AACA,gF;AACA,sC;AACA,K;AACA,0E;AACA,mC;AACA,K;AACA,8E;AACA,qC;AACA,K;;AAEA,2B;AACA,I;AACA,uC;AACA,oB;AACA,wB;AACA,kB;AACA,K;AACA,yE;AACA,yD;AACA,K;AACA,sE;AACA,uC;AACA,mE;AACA,K;AACA,8B;AACA,sD;AACA,0E;AACA,mB;AACA,K;AACA,uE;AACA,uE;AACA,oD;AACA,6C;AACA,mC;AACA,8D;AACA,6D;AACA,0E;AACA,mB;AACA,K;AACA,iC;AACA,yE;AACA,yE;AACA,4E;AACA,mB;AACA,K;AACA,gB;AACA,I;AACA,6B;AACA,oB;AACA,mC;AACA,I;AACA,wC;AACA,iD;AACA,iC;AACA,8C;AACA,G;AACA,G;;AAEA,wC;AACA,W;AACA,mE;AACA,kD;AACA,iB;AACA,uB;AACA,kB;AACA,yB;AACA,2B;AACA,yB;AACA,M;AACA,sC;AACA,mC;AACA,4D;AACA,c;AACA,4B;AACA,K;AACA,I;AACA,Y;AACA,wB;AACA,G;AACA,iD;AACA,kB;AACA,0D;AACA,iC;AACA,mE;AACA,0D;AACA,oC;;AAEA,U;AACA,kE;AACA,yD;AACA,wE;AACA,qE;AACA,wD;AACA,6D;AACA,+D;AACA,oB;AACA,6D;AACA,iE;AACA,sD;AACA,8E;AACA,8B;AACA,8C;AACA,4D;AACA,c;AACA,+D;AACA,8D;AACA,Q;AACA,I;AACA,sE;AACA,wC;AACA,4B;AACA,G;;;;;;;;;;;;;;;;;;;ACtJA,a;;AAEA,E;AACA,Y;;AAEA,6D;AACA,wE;AACA,sC;AACA,2E;AACA,2E;AACA,+B;;AAEA,E;AACA,iC;AACA,qD;AACA,2E;;AAEA,qC;AACA,sB;AACA,6B;AACA,I;AACA,4B;AACA,kB;AACA,4B;AACA,qB;AACA,I;AACA,iC;AACA,uB;AACA,sC;AACA,0B;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;AC/BA,G;AACA,a;AACA,kB;AACA,uB;AACA,gB;AACA,4C;AACA,G;;AAEA,a;;AAEA,yC;AACA,c;AACA,0C;;AAEA,gB;AACA,8B;AACA,yD;AACA,2B;AACA,mC;AACA,8B;AACA,+B;AACA,0E;;;AAGA,yC;AACA,iB;AACA,0C;;;AAGA,+B;AACA,8B;AACA,yB;AACA,K;;AAEA,O;AACA,wE;AACA,M;AACA,oF;AACA,6D;AACA,O;AACA,mD;AACA,4C;AACA,uB;;AAEA,4F;AACA,wE;;AAEA,wB;AACA,wE;AACA,yD;AACA,S;;AAEA,sB;AACA,K;;AAEA,yC;AACA,e;AACA,0C;;AAEA,sD;AACA,uC;AACA,mB;;AAEA,6D;AACA,wD;AACA,+C;AACA,4D;AACA,iD;AACA,sD;AACA,2C;AACA,8C;AACA,6C;AACA,S;;AAEA,wB;AACA,sB;AACA,K;;AAEA,uB;AACA,yC;AACA,uC;AACA,wC;AACA,gB;AACA,wC;AACA,yB;AACA,oB;AACA,4C;AACA,4E;AACA,mH;AACA,iB;;AAEA,+F;AACA,+L;AACA,iM;AACA,iM;AACA,mM;;AAEA,uF;AACA,gF;AACA,gD;;AAEA,wE;AACA,iH;;AAEA,0C;AACA,8B;AACA,qB;AACA,iB;;AAEA,oD;AACA,oc;;AAEA,sD;AACA,kE;AACA,a;AACA,S;AACA,oB;AACA,K;;AAEA,wC;AACA,sE;;AAEA,kC;AACA,uB;;AAEA,mD;AACA,wC;AACA,wB;AACA,8C;AACA,+C;AACA,wB;AACA,8C;AACA,gB;AACA,6C;AACA,S;;AAEA,4B;AACA,8C;;AAEA,8B;AACA,4B;AACA,uE;AACA,0C;AACA,wF;AACA,yC;AACA,oB;AACA,qF;AACA,a;AACA,gB;AACA,2C;AACA,0C;AACA,yF;AACA,yC;AACA,oB;AACA,qF;AACA,a;AACA,S;;AAEA,sB;AACA,K;;AAEA,0C;AACA,uB;AACA,mC;AACA,wC;AACA,wB;AACA,8C;AACA,gB;AACA,6C;AACA,S;;AAEA,0B;AACA,8C;AACA,uC;AACA,sC;AACA,8C;AACA,qC;AACA,gB;AACA,0C;AACA,S;AACA,sB;AACA,K;;AAEA,oC;AACA,+C;AACA,sE;AACA,gF;AACA,2H;AACA,K;;AAEA,mC;AACA,0C;AACA,4B;AACA,kE;AACA,qC;AACA,oB;AACA,iE;AACA,sB;AACA,4D;AACA,sB;AACA,qD;AACA,4C;AACA,sB;AACA,4D;AACA,sB;AACA,qD;AACA,S;AACA,+B;AACA,K;;AAEA,sC;AACA,yB;AACA,+B;AACA,0B;AACA,2B;AACA,yB;AACA,qC;;AAEA,wE;AACA,gD;AACA,8B;AACA,gB;AACA,mE;AACA,2C;AACA,4B;AACA,6C;AACA,a;;AAEA,4C;AACA,2C;AACA,sD;AACA,gD;AACA,+B;AACA,sD;AACA,wB;AACA,qD;AACA,iB;;AAEA,8C;AACA,+B;AACA,oF;AACA,mD;AACA,8E;AACA,8B;AACA,mF;AACA,kD;AACA,6E;AACA,8B;AACA,mF;AACA,kD;AACA,6E;AACA,+B;AACA,oF;AACA,kD;AACA,iB;AACA,a;;AAEA,6C;AACA,2C;AACA,yC;AACA,gD;AACA,gC;AACA,sD;AACA,wB;AACA,qD;AACA,iB;;AAEA,qF;AACA,4B;AACA,4B;;AAEA,wE;AACA,gD;AACA,oD;;AAEA,oD;AACA,wD;AACA,sC;AACA,8C;AACA,yB;AACA,8B;AACA,qB;AACA,iB;AACA,a;;AAEA,uC;AACA,2C;AACA,yC;AACA,gD;AACA,8B;AACA,sD;AACA,wB;AACA,qD;AACA,iB;;AAEA,qE;AACA,a;;AAEA,6C;AACA,8B;AACA,oD;AACA,a;;AAEA,kD;AACA,qD;AACA,oD;AACA,2B;AACA,gC;;AAEA,4B;AACA,kD;AACA,2D;AACA,qD;AACA,wG;AACA,wB;AACA,wD;AACA,iB;;AAEA,oC;;AAEA,6C;AACA,wF;AACA,wB;AACA,2B;AACA,iB;;AAEA,yD;AACA,2B;AACA,iB;AACA,oB;AACA,wC;AACA,a;;AAEA,4B;AACA,sC;AACA,+B;AACA,2B;AACA,a;;AAEA,iC;AACA,4H;AACA,a;;AAEA,4C;AACA,uB;AACA,a;;AAEA,sL;AACA,S;AACA,K;;AAEA,yC;AACA,wB;AACA,0C;;AAEA,+B;AACA,uC;AACA,kC;AACA,oC;AACA,sB;AACA,S;;AAEA,0C;AACA,M;;AAEA,qB;AACA,8B;;AAEA,6B;AACA,uC;AACA,sC;AACA,M;;AAEA,8E;AACA,2E;AACA,oB;AACA,8C;AACA,mB;AACA,mC;AACA,S;;AAEA,6B;AACA,kC;AACA,6D;AACA,a;AACA,kC;AACA,S;;AAEA,wC;AACA,sC;AACA,S;;AAEA,uB;AACA,M;;AAEA,4B;AACA,qB;AACA,2B;AACA,wB;AACA,U;AACA,wB;AACA,0B;AACA,yB;AACA,yB;AACA,yB;AACA,U;AACA,mC;AACA,gC;AACA,yD;AACA,sC;AACA,sC;AACA,4C;AACA,U;AACA,mB;AACA,uB;AACA,S;AACA,O;;AAEA,2C;AACA,0C;AACA,gC;AACA,gB;AACA,8B;AACA,S;AACA,M;;AAEA,yC;AACA,Y;AACA,0C;;AAEA,wC;AACA,gC;AACA,K;;;AAGA,yC;AACA,sB;AACA,0C;;;AAGA,sC;AACA,2B;AACA,iC;AACA,U;AACA,uC;AACA,0F;AACA,U;AACA,yC;AACA,4F;AACA,U;AACA,2B;AACA,2B;AACA,U;AACA,6B;AACA,2B;AACA,U;AACA,8B;AACA,oC;AACA,wB;AACA,U;AACA,8B;AACA,8C;AACA,wB;AACA,U;AACA,mC;AACA,8C;AACA,wB;AACA,U;AACA,mC;AACA,8C;AACA,wB;AACA,U;AACA,iC;AACA,8C;AACA,wB;AACA,U;AACA,qC;AACA,qD;;AAEA,iC;AACA,yC;AACA,a;;AAEA,8B;AACA,S;;AAEA,M;;AAEA,yC;AACA,qB;AACA,0C;;AAEA,iC;AACA,oB;AACA,iC;AACA,K;;AAEA,2B;AACA,uC;AACA,gF;AACA,oE;AACA,+C;AACA,kC;AACA,K;;AAEA,4B;AACA,qD;AACA,+B;AACA,2B;AACA,W;AACA,K;AACA,c","sourcesContent":["/* Just a simple console to get server console in client, Regz. RaiX 2013 */\n\n// Set true to get all logs from server start\nvar getAllLogs = false;\n// Enable / disable logging\nvar debug = false;\n\nif (!Meteor.Collection) {\n  console.log('No meteor??');\n}\n\nvar myConsole = new Meteor.Collection('_console');\n\nserverConsole = {\n\tlog: function (message) {\n\t\tif (debug) {\n\t\t\tconsole.log(message);\n\t\t\tmyConsole.insert({ message: message, createdAt: Date.now() });\n\t\t}\n\t}\n};\n\nvar timeConsole = Date.now();\n\nif (Meteor.isClient && debug) {\n\tMeteor.call('getTime', function(error, result) {\n\t\ttimeConsole = +result;\n\t\tif (error)\n\t\t\tconsole.log('getTime error: '+error.message);\n\t\tconsole.log('Got server time: '+result);\n\t\tDeps.autorun(function() {\n\t\t\tmyConsole.find({ createdAt: { $gt: timeConsole } }).forEach(function(doc) {\n\t\t\t\tconsole.log('SERVER: ' + doc.message);\n\t\t\t\ttimeConsole = doc.createdAt;\n\t\t\t});\n\t\t});\n\t});\n\n\tif (debug)\n\t\tMeteor.subscribe('myConsole');\n}\n\nif (Meteor.isServer && debug) {\n\n\tmyConsole.remove({});\n\n\tif (debug)\n\t\tMeteor.publish('myConsole', function() {\n\t\t\treturn myConsole.find({ createdAt : { $gt: timeConsole } });\n\t\t}, {is_auto: true});\n\n\tMeteor.methods({\n\t\tgetTime: function() {\n\t\t\tserverConsole.log('getTime');\n\t\t\treturn (getAllLogs)? 0 : Date.now()-20000; // Just add a little slack\n\t\t}\n\t});\n}\n","// REMOVE: When engien branche is merged with master in Meteor v0.6.0 ?\nif (typeof Npm === 'undefined') {\n  throw new Error('collectionFS: Please update Meteor');\n}\n  /*\n  // Polyfill for Npm\n  var path = __meteor_bootstrap__.require('path');\n  Npm = {\n    require: __meteor_bootstrap__.require,\n    bundleRoot: path.dirname(__meteor_bootstrap__.require.main.filename)\n  };\n} else { */\n  // Cannot rely on __meteor_bootstrap__.require.main.filename so we try this:\nif (! Npm.bundleRoot ) {\n  var path = Npm.require('path');\n  _.extend(Npm, {\n    bundleRoot: (process && process.mainModule &&\n            process.mainModule.filename)?\n            path.join(process.mainModule.filename, '..') : ''\n  });\n}\n//}\n\n// Test if we have found a bundleRoot\nif (! Npm.bundleRoot){\n  throw new Error('Cannot find bundle root directory');\n}\n/**** EO Npm polyfill extended bundleRoot ******/\n\n// Init config flags\n__meteor_runtime_config__.FILEHANDLER_SUPPORTED = false;\n\n__filehandlers = {\n  // Filesystem configuration\n  folder: 'cfs',\n  // Main folder to place collectionFS filehandler folders in\n\n  serverPath: '',         // Auto\n  bundlePath: '',         // Auto\n  url: '',                // Auto\n  rootDir: '',            // Auto\n  bundleStaticPath: '',   // Auto\n  bundleRoot: '',         // Auto\n  created: false,         // Auto\n\n  // Configuration flags\n  MaxRunning: 1,\n  // Max filehandlers running at the same time in total on server,\n  // not pr. collectionFS\n\n  Running: 0,\n  // Filehandlers running at the same time in total on server,\n  // not pr. collectionFS\n\n  MaxFailes: 3,\n  // Retries each failed filehandler 3 times and moves on to next failed\n\n  // Allow a reset of filehandler failures to try again?\n  AllowFailesRetry: 60*1000,\n  // Wait ms before trying again, if == 0 then disabled\n\n  _AllowFailesRetryLastTime: 0,\n  // Auto - Carry for wait timer\n\n  // How often to run filehandlers pr. file\n  waitBeforeCheckingQueue: 1000,\n  // Default 1000ms / 1sec, 0 disables filehandlers\n\n  waitBeforeCheckingQueueWhenNoFilehandlers: 5000\n  // Default 5000ms / 5sec - no filehandlers defined yet, we wait? 0 disables\n};\n\n\nvar fs = Npm.require('fs');\nvar path = Npm.require('path');\n\n__filehandlers.url = '/' + __filehandlers.folder;\n__filehandlers.bundleRoot = Npm.bundleRoot;\n__filehandlers.rootDir =\n        path.join(__filehandlers.bundleRoot, '..') + path.sep;\n__filehandlers.bundleStaticPath =\n        path.join(__filehandlers.bundleRoot, 'static');\n__filehandlers.bundlePath =\n        path.join(__filehandlers.bundleStaticPath, __filehandlers.folder);\n__filehandlers.serverPath =\n        path.join(__filehandlers.rootDir, __filehandlers.folder);\n\nserverConsole.log('bundlePath: '+__filehandlers.bundlePath);\nserverConsole.log('serverPath: '+__filehandlers.serverPath);\n\n// Check if the bundle static folder exists, if not then create Issue #40\nif (!fs.existsSync(__filehandlers.bundleStaticPath)){\n  fs.mkdirSync(__filehandlers.bundleStaticPath);\n}\n\n// Remove symlink\ntry {\n  fs.rmdirSync(__filehandlers.bundlePath);\n} catch(e) { /* NOP */}\n\ntry {\n  fs.unlinkSync(__filehandlers.bundlePath);\n} catch(e) { /* NOP  */}\n\n// Check if server path exists, if not then create\nif (!fs.existsSync(__filehandlers.serverPath)){\n  fs.mkdirSync(__filehandlers.serverPath);\n}\n\n// Create symlink\nif (!!fs.existsSync(__filehandlers.serverPath)) {\n  serverConsole.log('Create symlinkSync');\n  fs.symlinkSync( __filehandlers.serverPath, __filehandlers.bundlePath );\n}\n\n__filehandlers.created = (!!fs.existsSync(__filehandlers.bundlePath));\n\n__meteor_runtime_config__.FILEHANDLER_SUPPORTED =\n        fs.existsSync(__filehandlers.serverPath);\n\n","/* CollectionFS.js\n * A gridFS kind implementation.\n * 2013-01-03\n *\n * By Morten N.O. Henriksen, http://gi2.dk\n *\n */\n\"use strict\";\n\nvar fs = Npm.require('fs');\nvar path = Npm.require('path');\n\n// Transform api onto file objects\n_fileObject = function(doc, collection) {\n  var self = this;\n  self.collection = collection;\n  _.extend(self, doc);\n};\n\n// @export CollectionFS\nCollectionFS = function(name, options) {\n\tvar self = this;\n\tself._name = name;\n  // Map server api as transformation\n\tself.files = new Meteor.Collection(self._name+'.files', {\n    transform: function(doc) {\n      return new _fileObject(doc, self);\n    }\n  });\n  // TODO: Add change listener?\n  self.chunks = new Meteor.Collection(self._name+'.chunks');\n\tself.queue = new _queueCollectionFS(name);\n\tself._fileHandlers = {}; // Set by function fileHandlers({});\n  self._filter = null;  // Set by function filter({});\n\tvar methodFunc = {};\t\t\t\t\t\t\t\t\t\t// Server methods\n\n\tserverConsole.log('CollectionFS: ' + name);\n\n\t// Extend _options\n\tself._options = { autopublish: true,\n          maxFilehandlers: __filehandlers.MaxRunning\n  };\n\t_.extend(self._options, options);\n\n  //events\n  self._events = {\n    'ready': function() {},\n    'invalid': function() {}, //arg1 = CFSErrorType enum, arg2 = fileRecord\n    'progress': function() {}, //arg1 = progress percentage as integer\n    'start': function() {},\n    'stop': function() {},\n    'resume': function() {}\n  };\n\n\t// User is able to set maxFilehandlers - could be other globals to if needed\n\t__filehandlers.MaxRunning = self._options.maxFilehandlers;\n\n\t// Setup autopublish if not flag'ed out\n\tif (self._options.autopublish) {\n    Meteor.publish(self._name+'.files', function () {\n      return self.find({});\n    }, {is_auto: true});\n\t} //EO Autopublish\n\n\t// Save data into file in collection\n\tmethodFunc['saveChunck'+self._name] =\n          function(fileId, chunkNumber, countChunks, data) {\n    this.unblock();\n\t\tif ( fileId ) {\n\n\t\t\tvar cId = self.chunks.insert({\n\t\t\t\t\"files_id\" : fileId,  // _id of the corresponding files collection entry\n        \"n\" : chunkNumber,          // chunks are numbered in order, starting with 0\n        \"data\" : data // the chunk's payload as a BSON binary type\n\t\t\t});\n\n\t\t\tif (cId) { //If chunk added successful\n\t\t\t\tvar numChunks = self.chunks.find({ \"files_id\": fileId }).count();\n\n\t\t\t\tself.files.update({ _id: fileId }, {\n\t\t\t\t\t$set: {\n            complete: (countChunks === numChunks),\n            currentChunk: chunkNumber+1,\n            numChunks: numChunks\n          }\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tfileId: fileId,\n\t\t\t\t\tchunkId: cId,\n\t\t\t\t\tcomplete: (countChunks === numChunks),\n\t\t\t\t\tcurrentChunk: chunkNumber+1\n\t\t\t\t};\n\n\t\t\t} //If cId\n\t\t} //EO got fileId\n\t}; //EO saveChunck+name\n\n\t// Return requested data from chunk in file\n\tmethodFunc['loadChunck'+self._name] = function(fileId, chunkNumber, countChunks) {\n    this.unblock();\n\t\tif ( fileId ) {\n\t\t\tvar chunk = self.chunks.findOne({\n\t\t\t\t\"files_id\" : fileId,  // _id of the corresponding files collection entry\n        \"n\" : chunkNumber          // chunks are numbered in order, starting with 0\n      });\n\n\t\t\treturn {\n\t\t\t\tfileId: fileId,\n\t\t\t\tchunkId: chunk._id,\n\t\t\t\tcurrentChunk:chunkNumber,\n\t\t\t\tcomplete: (chunkNumber === countChunks-1),\n\t\t\t\tdata: chunk.data\n\t\t\t};\n\t\t} //EO fileId\n\t}; //EO saveChunck+name\n\n\tmethodFunc['getMissingChunk'+self._name] = function(fileId) {\n\t\t//console.log('getMissingChunk: '+fileRecord._id);\n\t\tvar self = this;\n\t\tvar fileRecord = self.files.findOne({_id: fileId});\n\n\t\tif (fileRecord) {\n\t\t\t//Check file chunks if they are all there\n\t\t\t//Return missing chunk id\n\t\t\tif (fileRecord.currentChunk === fileRecord.countChunks) { //Ok\n\t\t\t\tfor (var cnr = 0; cnr < fileRecord.countChunks; cnr++) {\n\t\t\t\t\t//Really? loop though all chunks? cant mongo or gridFS\n          // do this better? TODO: Readup specs/docs\n          if (!self.chunks.findOne({\n            files_id: fileRecord._id,\n            n: cnr\n          },\n            { fields: { data:0 } })) {\n            //File error - missing chunks..\n\t\t\t\t\t\treturn cnr; //Return cnr that is missing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false; //Checked and good to go (need md5?)\n\t\t\t} else {\n\t\t\t\treturn fileRecord.currentChunk;\n        //return missing chunk to continue - fileupload not complete\n      }\n\t\t} else {\n\t\t\t// No fileRecord found\n\t\t\tthrow new Error('getMissingChunk file not found: ' + fileId);\n\t\t}\n\t}; //EO getMissingChunk\n\n\t// Add object specific server methods\n\tMeteor.methods(methodFunc);\n\n\t//Init queueListener for fileHandling at the server\n  Meteor.startup(function () {\n    //Ensure chunks index on files_id and n\n    self.chunks._ensureIndex({ files_id: 1, n: 1 }, { unique: true });\n\t\t//Spawn queue listener\n\t\tself.queueListener = new _queueListener(self);\n\n\t\t// Add observer removed\n    self.files.find(arguments, options).observe({\n        removed: function(doc) {\n            // remove all chunks, make sure _id isset, don't mess up\n            if (doc._id) {\n              self.chunks.remove({ files_id: doc._id });\n            }\n            // Check to se if any filehandlers worked the file\n            if (Object.keys(doc.fileHandler).length > 0) {\n              // Walk through the filehandlers\n              _.each(doc.fileHandler, function(fileHandler, func) {\n                // If url isset and beginning with '/' we have a local file?\n                if (fileHandler.url && fileHandler.url.substr(0, 1) === '/') {\n                  // Reconstruct local absolute path to file\n                  var myServerPath = path.join(\n                          __filehandlers.rootDir,\n                          fileHandler.url.substr(1));\n                  // If file exists then\n                  if (!!fs.existsSync(myServerPath) ){\n                    try {\n                      // Remove the file\n                      fs.unlinkSync(myServerPath);\n                    } catch(e) { /* NOP */ }\n                  } // EO fileexists\n                } // Local file\n              }); // EO each\n            } // EO fileHandler's found\n          } // EO removed\n      }); // EO Observer\n\n\t}); // Startup\n\n}; //EO collectionFS\n\n_queueCollectionFS = function(name) {\n\tvar self = this;\n\tself._name = name;\n};\n","// Server cache worker, idear:\n//\n// Basics\n// On server load init worker and taskQue if needed by collection\n// if (fileHandlers)\n// When client confirms uploads run user defined functions on file described in\n// fileHandlers\n// if null returned then proceed to the next function in fileHandler array\n// if data returned then put it in a file in eg.:  uploads/cfs/collection._name\n// folder and update url array reference in database, triggers reactive\n// update UI\n// Note: updating files in uploads refreshes server? - find solution later,\n// maybe patch meteor core?\n//\n// In model:\n// CollectionFS.fileHandlers({\n//   //Default image cache\n//   handler['default']: function(fileId, blob) {\n//     return blob;\n//   },\n//   //Some specific\n//   handler['40x40']: function(fileId, blob) {\n//      //Some serverside image/file handling functions, user can define this\n//      return blob;\n//    },\n//   //Upload to remote server\n//   handler['remote']: function(fileId, blob) {\n//      //Some serverside imagick/file handling functions, user can define this\n//      return null;\n//    },\n//\n// });\n//\n// Server:\n// on startup queueListener spawned if needed by collectionFS - one\n// queueListener pr collectionFS\n// queueListener spawns fileHandlers pr. item in fileHandlerQue as\n// setTimeout(, 0) and delete item from queue\n// if empty queue then die and wait, spawn by interval\n// server sets .handledAt = Date.now(), .fileHandler[]\n// fileHandlers die after ended\n// Filehandlers respect __filehandlers.MaxRunning on server, set to 1 pr.\n// default for throttling the server.\n//\n// Client:\n// When upload confirmed complete, set fs.files.complete and add _id to\n// collectionFS.fileHandlerQue (wich triggers a worker at interval)\n//\n\n//var queueListener = new _queueListener();\n\n\"use strict\";\n\nvar fs = Npm.require('fs');\nvar path = Npm.require('path');\n\n_.extend(_fileObject.prototype, {\n  // Expect self to have the properties of fileRecord\n  // Added is self.collection for access to the collection the file belongs\n\n\n  filehandler: {  // TODO: Add filehandlers file object api\n    destination: function(newExtension) { // destination\n      // TODO: Refractor destination\n    },\n    push: function(filehandler, destinationObject) {\n      // TODO: Add / Update filehandler\n    },\n    pop: function(filehandler, destinationObject) {\n      // TODO: Remove filehandler\n    }\n  }\n});\n\n_queueListener = function(collectionFS) {\n\tvar self = this;\n\tself.collectionFS = collectionFS;\n\n    // Init directory for collection\n\tself.serverPath = path.join(__filehandlers.serverPath,\n          self.collectionFS._name);  // Server path\n\tself.pathURL = __filehandlers.url + '/' + self.collectionFS._name; // Url path\n\n\tif (!fs.existsSync(self.serverPath)) {\n    fs.mkdirSync(self.serverPath);\n  }\n\n\tself.pathCreated = (!!fs.existsSync(self.serverPath));\n\n\t//Spawn worker:\n\tMeteor.setTimeout(function() { self.checkQueue(); }, 0); //Init worker process\n\n};//EO queueListener\n\n_.extend(_queueListener.prototype, {\n\tcheckQueue: function() {\n\t\tvar self = this;\n\t\t//check items in queue and init workers for conversion\n\t\tif (self.collectionFS) {\n\t\t\tif (self.collectionFS._fileHandlers) {\n\t\t\t\t//ok got filehandler object, spawn worker?\n\t\t\t\tif (__filehandlers.Running < __filehandlers.MaxRunning) {\n\t\t\t\t\t__filehandlers.Running++;\n\n\t\t\t\t\t// First, Try to find new unhandled files\n\t\t\t\t\tvar fileRecord = self.collectionFS.findOne({ handledAt: null,\n                  complete: true }); //test sumChunk == countChunks in mongo?\n\n\t\t\t\t\t// Second, check if not complete and remoteFile is set then we have\n          // an load file order\n          if (!fileRecord) {\n            fileRecord = self.collectionFS.findOne({\n              $exists: { remoteFile: true },\n              complete: false\n            }); //test sumChunk == countChunks in mongo?\n          }\n\t\t\t\t\t// Third, Try to find new filehandlers, not yet applied\n\t\t\t\t\tif (!fileRecord) {\n\t\t\t\t\t\t// Create a query array from filehandlers\n\t\t\t\t\t\tvar queryFilehandlersExists = [];\n\t\t\t\t\t\tfor (var func in self.collectionFS._fileHandlers) {\n\t\t\t\t\t\t\tvar queryExists = {};\n\t\t\t\t\t\t\tqueryExists['fileHandler.'+func] = { $exists: false };\n\t\t\t\t\t\t\tqueryFilehandlersExists.push(queryExists);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\tWhere one of the fileHandlers are missing\n            if (queryFilehandlersExists.length > 0) {\n              fileRecord = self.collectionFS.findOne({ complete: true,\n                                   $or: queryFilehandlersExists,\n                                   'fileHandler.error': { $exists: false } });\n            }\n\t\t\t\t\t} // EO Try to find new filehandlers\n\n\t\t\t\t\t// Last, Try to find failed filehanders\n\t\t\t\t\tif (!fileRecord) {\n\t\t\t\t\t\t// Create a query array from filehandlers\n\t\t\t\t\t\tvar queryFilehandlersFailed = [];\n\t\t\t\t\t\tfor (var func in self.collectionFS._fileHandlers) {\n\t\t\t\t\t\t\tvar queryFailed = {};\n\t\t\t\t\t\t\tqueryFailed['fileHandler.' + func + '.failed'] = { $exists: true,\n                      $lt: __filehandlers.MaxFailes,\n                      'fileHandler.error': { $exists: false } };\n\t\t\t\t\t\t\tqueryFilehandlersFailed.push(queryFailed);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//  Where the fileHandler contains an element with a failed set less\n            //  than __filehandlers.MaxFailes\n            if (queryFilehandlersFailed.length > 0) {\n              fileRecord = self.collectionFS.findOne({ complete: true,\n                                   $or: queryFilehandlersFailed });\n            }\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle file, spawn worker\n\t\t\t\t\tif (fileRecord) {\n\n\t\t\t\t\t\t// Test if remoteFile isset\n\t\t\t\t\t\tif (fileRecord.remoteFile){\n              self.workLoadRemoteFile(fileRecord);\n            }else{\n              self.workFileHandlers(fileRecord,\n                      self.collectionFS._fileHandlers);\n            }\n\t\t\t\t\t\t// Update idle\n\t\t\t\t\t\t__filehandlers._AllowFailesRetryLastTime = Date.now();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We shouldn't get bored, are we going to retry failed filehandlers\n            // or sleep a bit or eight?\n\t\t\t\t\t\tif (__filehandlers.AllowFailesRetry ) {\n\t\t\t\t\t\t\tvar waitedEnough = ((__filehandlers._AllowFailesRetryLastTime +\n                      __filehandlers.AllowFailesRetry) < Date.now());\n\t\t\t\t\t\t\t// We wait a period before retrying\n\t\t\t\t\t\t\tif ( waitedEnough ) {\n                for (var func in self.collectionFS._fileHandlers) {\n                  // reset failed to 1 on all failed filehandlers, triggering a\n                  // restart of failed retry\n                  var queryFailed = {};\n                  var querySetFailed = {};\n                  queryFailed['fileHandler.' + func + '.failed'] =\n                          { $exists: true };\n                  querySetFailed['fileHandler.' + func + '.failed'] = 1;\n                  // We do reset pr. filehandler\n                  self.collectionFS.update(queryFailed,\n                          { $set: querySetFailed });\n                }\n              }  // EO for\n\t\t\t\t\t\t} // EO restart handling failed handlers?\n\t\t\t\t\t} // EO No fileRecord found\n\n\t\t\t\t\t__filehandlers.Running--;\n\t\t\t\t} // EO Filehandler\n\n\t\t\t\tif (__filehandlers.waitBeforeCheckingQueue) {\n          Meteor.setTimeout(function() { self.checkQueue(); },\n                  __filehandlers.waitBeforeCheckingQueue); //Wait a second 1000\n        }\n\t\t\t} else {\n\t\t\t\tif (__filehandlers.waitBeforeCheckingQueueWhenNoFilehandlers) {\n          Meteor.setTimeout(function() { self.checkQueue(); },\n                  __filehandlers.waitBeforeCheckingQueueWhenNoFilehandlers);\n          //Wait 5 second 5000\n        }\n\t\t\t}\n\t\t} //No collection?? cant go on..\n\t}, //EO checkQueue\n\n\tworkFileHandlers: function(fileRecord, fileHandlers) {\n\t\tvar self = this;\n\n\t\t//Retrive blob\n\t\tvar blob = self.collectionFS.retrieveBuffer(fileRecord._id);\n\n\t\t// If file is ready\n\t\tif (blob && blob.length > 0) {\n\t\t\t//do some work, execute user defined functions\n\t\t\tfor (var func in fileHandlers) {\n\t\t\t\t// Is filehandler allready found?\n\t\t\t\tvar filehandlerFound = (fileRecord.fileHandler &&\n                fileRecord.fileHandler[func]);\n\n\t\t\t\t// Set sum of filehandler failures - if not found the default to 0\n\t\t\t\tvar sumFailes = (filehandlerFound &&\n                fileRecord.fileHandler[func].failed)?\n                fileRecord.fileHandler[func].failed : 0;\n\t\t\t\t// if not filehandler or filehandler found in fileRecord. fileHandlers\n        // then check if failed\n\t\t\t\tif (! filehandlerFound ||\n                ( sumFailes && sumFailes < __filehandlers.MaxFailes) ) {\n\n\t\t\t\t\t// destination - a helper for the filehandlers\n\t\t\t\t\t// [newExtension] is optional and with/without a leading '.'\n\t\t\t\t\t// Returns\n\t\t\t\t\t// serverFilename - where the filehandler can write the file if wanted\n\t\t\t\t\t// fileData - contains future url reference and extension for the\n\t\t\t\t\t// database\n          // TODO: destination should somehow be added to server-side\n          // fileobject api - Look in top of this file\n\t\t\t\t\tvar destination = function(newExtension) {\n\t\t\t\t\t\t// Make newExtension optional, fallback to fileRecord.filename\n\t\t\t\t\t\tvar extension = (newExtension)?\n                    newExtension : path.extname(fileRecord.filename);\n\t\t\t\t\t\t// Remove optional leading '.' from extension name\n\t\t\t\t\t\textension = (extension.substr(0, 1) === '.')?\n                    extension.substr(1) : extension;\n\t\t\t\t\t\t// Construct filename from '_id' filehandler name and extension\n\t\t\t\t\t\tvar myFilename = fileRecord._id + '_' + func + '.' + extension;\n\t\t\t\t\t\t// Construct url TODO: Should URL encode (could cause trouble in\n            // the remove observer)\n\t\t\t\t\t\tvar myUrl = self.pathURL + '/' + myFilename;\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tserverFilename: path.join(self.serverPath, myFilename),\n\t\t\t\t\t\t\tfileData: {\n\t\t\t\t\t\t\t\turl: myUrl,\n\t\t\t\t\t\t\t\textension: extension.toLowerCase()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}; // EO destination\n\n\t\t\t\t\t// We normalize filehandler data preparing it for the database\n\t\t\t\t\t// func is the filehandler eg. \"resize256\"\n\t\t\t\t\t// fileData is the data to return from the file handler, eg. url and\n          // extension\n\t\t\t\t\tvar normalizeFilehandle = function(func, fileData) {\n\t\t\t\t\t\tvar myData = {};\n\t\t\t\t\t\tmyData['fileHandler.'+func] = (fileData)?fileData:{};\n\t\t\t\t\t\tmyData['fileHandler.'+func].createdAt = Date.now();\n\t\t\t\t\t\treturn myData;\n\t\t\t\t\t};\n\n          var result = false;\n\t\t\t\t\ttry {\n            // TODO: set `this` to file object\n\t\t\t\t\t\tresult = fileHandlers[func]({\n              fileRecord: fileRecord,\n              blob: blob,\n              destination: destination,\n              sumFailes: sumFailes\n            });\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\tthrow new Error('Error in filehandler: \"' + func + '\" ' +\n                    (e.trace || e.message));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) { //A result means do something for user defined function\n\t\t\t\t\t\t//Save on filesystem\n\t\t\t\t\t\tif (result.blob) {\n\t\t\t\t\t\t\t//save the file and update fileHandler\n\n\t\t\t\t\t\t\tfs.writeFileSync(destination(result.extension).serverFilename,\n                      result.blob);\n\n\t\t\t\t\t\t\t//Add to fileHandler array\n\t\t\t\t\t\t\tif (fs.existsSync(destination(result.extension).serverFilename)) {\n\t\t\t\t\t\t\t\tself.collectionFS.files.update({ _id: fileRecord._id }, {\n\t\t\t\t\t\t\t\t\t$set: normalizeFilehandle(func,\n                          destination(result.extension).fileData)\n\t\t\t\t\t\t\t\t}); //EO Update\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// File could not be written to filesystem? Don't try this\n                // filehandler again\n\t\t\t\t\t\t\t\tself.collectionFS.files.update({ _id: fileRecord._id }, {\n\t\t\t\t\t\t\t\t\t$set: normalizeFilehandle(func,\n                    { error: 'Filehandler could not write to filesystem' })\n\t\t\t\t\t\t\t\t}); //EO Update\n\n\t\t\t\t\t\t\t\tthrow new Error('Filehandler \"' + func +\n                        '\" could not write to filesystem');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//no blob? Just save result as filehandler data\n\t\t\t\t\t\t\tself.collectionFS.files.update({ _id: fileRecord._id }, {\n\t\t\t\t\t\t\t\t$set: normalizeFilehandle(func, result)\n\t\t\t\t\t\t\t}); //EO Update\n\n\t\t\t\t\t\t} //EO no blob\n\t\t\t\t\t} else {  //Otherwise guess filehandler wants something else?\n\t\t\t\t\t\tif (result === null) {\n\n\t\t\t\t\t\t\t//if null returned then ok, dont run again - we update the db\n\t\t\t\t\t\t\tself.collectionFS.files.update({ _id: fileRecord._id }, {\n\t\t\t\t\t\t\t\t$set: normalizeFilehandle(func)\n\t\t\t\t\t\t\t}); //EO Update\n\n\t\t\t\t\t\t} else { // But if false then we got an error - handled by the queue\n\n\t\t\t\t\t\t\t// Do nothing, try again sometime later defined by config policy\n\t\t\t\t\t\t\tself.collectionFS.files.update({ _id: fileRecord._id }, {\n\t\t\t\t\t\t\t\t$set: normalizeFilehandle(func, { failed: (sumFailes+1) })\n\t\t\t\t\t\t\t}); //EO Update\n\n\t\t\t\t\t\t}//EO filehandling failed\n\t\t\t\t\t} //EO no result\n\n\t\t\t\t} // EO if allready found or max failures reached\n\t\t\t} //EO Loop through fileHandler functions\n    } // EO if\n    //Update fileHandler in db\n    self.collectionFS.files.update({ _id: fileRecord._id },\n            { $set: { handledAt: Date.now() } });\n\t}, //EO workFileHandlers\n\tworkLoadRemoteFile: function(fileRecord) {\n\t\t// Read remoteFile address and go fetch the remote file...\n\t\t// TODO: Maybe allow for setting of a header / auth etc. ?\n\t\tthrow new Error('Serverside file fetching not implemented');\n\t}\n});//EO queueListener extend\n\n","\"use strict\";\n\n_.extend(CollectionFS.prototype, {\n\tstoreBuffer: function(filename, buffer, options) {\n\n\t\t// Check filename\n\t\tif (!filename || filename !== ''+filename ) {\n      throw new Error('storeBuffer requires filename ' +\n              'string as first parametre');\n    }\n\n\t\t// Check buffer\n\t\tif (!buffer || buffer.length < 1) {\n      throw new Error('storeBuffer requires a Buffer as second parametre');\n    }\n\n\t\tvar self = this;\n\t\tvar fileId = null;\n\n\t\t// Set encoding for file\n\t\tvar encoding = (options && options.encoding) ? options.encoding : 'utf-8';\n\n\t\t// Simulate clienside file keys\n\t\tvar file = {\n\t\t\tname: filename,\n\t\t\tsize: buffer.length,\n\t\t\tencoding: encoding,\n\t\t\ttype: (options && options.contentType)? options.contentType : '',\n\t\t\towner: (options && options.owner)? options.owner : ''\n\t\t};\n\t\tvar metadata = (options && options.metadata)?options.metadata : null;\n\n\t\t// Generate new fileRecord\n\t\tvar fileRecord = self.queue.makeGridFSFileRecord(file, metadata);\n\n\t\t// Insert file record into database\n\t\tfileId = self.files.insert(fileRecord);\n\n\t\t// Check that we are ok\n\t\tif (!fileId) {\n      throw new Error('storeBuffer could not create file \"' + filename +\n              '\" in database');\n    }\n\n    //Put file in upload queue\n\t\tfor (var n = 0; n < fileRecord.countChunks; n++) {\n\n\t\t\t// Handle each chunk\n\t\t\tvar data = buffer.toString(encoding, (n * fileRecord.chunkSize),\n              ( (n * fileRecord.chunkSize) + (fileRecord.chunkSize)) );\n\n\t\t\t// Save data chunk into database\n\t\t\tvar cId = self.chunks.insert({\n\t\t\t\t\"files_id\" : fileId, // _id of the corresponding files collection entry\n        \"n\" : n, // chunks are numbered in order, starting with 0\n\t\t\t\t\"data\" : data // the chunk's payload as a BSON binary type\n\t\t\t});\n\n\t\t\t// Check that we are okay\n\t\t\tif (!cId) {\n        throw new Error('storeBuffer can not create chunk ' + n + ' in file ' +\n                filename);\n      }\n\n      // Update progress or just when completed, use option.noProgress to change\n\t\t\tif (! (options && options.noProgress === true) ||\n              n === fileRecord.countChunks - 1) {\n        self.files.update({ _id: fileId }, { $set: {\n          currentChunk: n,\n          numChunks: n+1,\n          complete: (n === fileRecord.countChunks - 1)\n        } });\n      }\n\t\t} // EO chunk iteration\n\n\t\t// Return the newly created file id\n\t\treturn fileId;\n\t}, // EO storeBuffer\n\n\tretrieveBuffer: function(fileId) {\n\t\tif (!fileId) {\n      throw new Error('retrieveBuffer require a file id as parametre');\n    }\n\t\t// Load file from database\n\t\tvar self = this;\n\n\t\t// Get file file record\n\t\tvar fileRecord = self.files.findOne({ _id: fileId });\n\t\tif (!fileRecord) {\n      throw new Error('retrieveBuffer can not find file on id: ' + fileId);\n    }\n\t\t// Check if file is ready / a uploadDate\n    // TODO: clean up remove complete from fileRecord\n\t\tif (!fileRecord.uploadDate || !fileRecord.countChunks ||\n              fileRecord.numChunks !== fileRecord.countChunks) {\n      return;\n    }\n\t\t// Note: Newer fileRecords should have an encoding specified\n\t\t// but this helps maintain backward compatibility\n\t\tvar encoding = (fileRecord.encoding) ? fileRecord.encoding : 'utf-8';\n\n\t\t// Get size of blob\n\t\tvar fileSize = +fileRecord['length']; //+ Due to Meteor issue\n\n\t\t//Allocate mem\n\t\tvar blob = new Buffer(fileSize, encoding);\n\n\t\t// Try to get all the chunks\n\t\tvar query = self.chunks.find({ files_id: fileId }, { sort: {n: 1} });\n\n\t\t//\n\t\tif (query.count() === 0) {\n\t\t\t// A completed file with no chunks is corrupted, remove\n\t\t\tif ( fileRecord.complete ) {\n        self.remove({ _id: fileId });\n      }\n\t\t\treturn;\n\t\t} // EO No chunks in file\n\n\t\tquery.rewind();\n\n\t\t// Create the file blob for the filehandlers to use\n\t\tquery.forEach(function(chunk){\n\t\t\tif (! chunk.data ) {\n\t\t\t\t// Somethings wrong, we'll throw an error\n\t\t\t\tthrow new Error('Filehandlers for file id: ' + fileId +\n                ' got empty data chunk.n:' + chunk.n);\n      }\n\n\t\t\t// Write chunk data to blob using the given encoding\n\t\t\t// if(chunk.data.length > 0) {\n\t\t\t// blob.write(chunk.data, (chunk.n * fileRecord.chunkSize),\n      //        chunk.data.length, encoding);\n      // }\n\t\t\t// Finally do the data appending\n\t\t\tfor (var i = 0; i < chunk.data.length; i++) {\n\t\t\t\tblob[(chunk.n * fileRecord.chunkSize) + i] = chunk.data.charCodeAt(i);\n\t\t\t\t//blob.writeUInt8( ((chunk.n * fileRecord.chunkSize) + i),\n        //        chunk.data.charCodeAt(i) );\n      }\n\t\t}); //EO find chunks\n\n\t\treturn blob;\n\t} // EO retrieveBuffer\n});\n\n_.extend(_queueCollectionFS.prototype, {\n\taddFile: function(fileId, buffer) {\n\t\t// Load buffer chunks into chunks for fileId\n\t},\n\tgetFile: function(fileId) {\n\t\t// Load chunks into\n\n\t}\n});\n","\"use strict\";\n\n/*\n  SERVER API\n\n  The fileObject is equal to the fileRecord + server-side api\n  This pattern will allow easier manipulation of files since we now pass\n  file objects with methods attatched.\n  In many cases we are only passed content objects with no reference to the\n  collection attached - This way we actually know were the data belongs and\n  makes operations much easier.\n\n*/\n_.extend(_fileObject.prototype, {\n  // Expect self to have the properties of fileRecord\n  // Added is self.collection for access to the collection the file belongs\n\n  // TODO: Add server file object api\n  remove: function() {\n    // TODO: Remove this file\n  },\n  getExtension: function() {\n    var extension;\n    // TODO: parse extension\n    return extension;\n  },\n  getUrl: function(filehandler) {\n    var filehandlerUrl;\n    // TODO: return url to filehandler\n    return filehandlerUrl;\n  }\n});","\"use strict\";\n\n//utility functions\n// Todo: should be transformed on to file objects?\ngetFileExtension = function(name) {\n  var found = name.lastIndexOf('.') + 1;\n  return (found > 0 ? name.substr(found) : \"\");\n};\n\ncontentTypeInList = function(list, contentType) {\n  var listType, found = false;\n  for (var i = 0, ln = list.length; i < 10; i++) {\n    listType = list[i]; // TODO: if i > ln\n    if (listType === contentType) {\n      found = true;\n      break;\n    }\n    if (listType === \"image/*\" && contentType.indexOf(\"image/\") === 0) {\n      found = true;\n      break;\n    }\n    if (listType === \"audio/*\" && contentType.indexOf(\"audio/\") === 0) {\n      found = true;\n      break;\n    }\n    if (listType === \"video/*\" && contentType.indexOf(\"video/\") === 0) {\n      found = true;\n      break;\n    }\n  }\n  return found;\n};\n\nsetObjByString = function(obj, str, val) {\n  var keys, key;\n  //make sure str is a nonempty string\n  if (str === ''+str && str !== '') {\n    return false;\n  }\n  if (!Match.test(obj, {})) {\n    //if it's not an object, make it one\n    obj = {};\n  }\n  keys = str.split(\".\");\n  while (keys.length > 1) {\n    key = keys.shift();\n    if (obj !== Object(obj)) {\n      //if it's not an object, make it one\n      obj = {};\n    }\n    if (!(key in obj)) {\n      //if obj doesn't contain the key, add it and set it to an empty object\n      obj[key] = {};\n    }\n    obj = obj[key];\n  }\n  return obj[keys[0]] = val; // TODO: Are we checking or setting?\n};\n\n// TODO: Refractor code:\n// use check(str, String); or Match.test(str, String);\nisString = function() {\n  throw Error('isString deprecated');\n  // return Object.prototype.toString.call(str) === \"[object String]\";\n};\n/*\nNonEmptyString = Match.Where(function (x) {\n  check(x, String);\n  return x.length > 0;\n}\n*/\n\n// TODO: refractor use: !!(check(str, String) && str.length > 0)\nisNonEmptyString = function() {\n  throw Error('isNonEmptyString deprecated');\n  // return isString(str) && str.length;\n};\n\n// TODO: refractor to use: check(obj, Object)\nisObject = function() {\n  throw Error('isObject deprecated');\n  // return obj === Object(obj);\n};\n\nvar cleanOptions = function() {\n  throw Error('cleanOptions deprecated');\n  // return options;\n};\n","\"use strict\";\n\n// Make files basic functions available in CollectionFS\n_.extend(CollectionFS.prototype, {\n\tfind: function() {\n    return this.files.find.apply(this.files, arguments);\n  },\n\tfindOne: function() {\n    return this.files.findOne.apply(this.files, arguments);\n  },\n\tupdate: function() {\n    return this.files.update.apply(this.files, arguments);\n  },\n\tremove: function() {\n    return this.files.remove.apply(this.files, arguments);\n  },\n\tallow: function() {\n    return this.files.allow.apply(this.files, arguments);\n  },\n\tdeny: function() {\n    return this.files.deny.apply(this.files, arguments);\n  },\n\tfileHandlers: function(options) {\n    _.extend(this._fileHandlers, options);\n  },\n  filter: function(options) {\n    //clean up filter option values\n    if (!options.allow || !Match.test(options.allow, Object)) {\n      options.allow = {};\n    }\n    if (!options.deny || !Match.test(options.deny, Object)) {\n      options.deny = {};\n    }\n    if (!options.maxSize || !_.isNumber(options.maxSize)) {\n      options.maxSize = false;\n    }\n    if (!options.allow.extensions || !_.isArray(options.allow.extensions)) {\n      options.allow.extensions = [];\n    }\n    if (!options.allow.contentTypes || !_.isArray(options.allow.contentTypes)) {\n      options.allow.contentTypes = [];\n    }\n    if (!options.deny.extensions || !_.isArray(options.deny.extensions)) {\n      options.deny.extensions = [];\n    }\n    if (!options.deny.contentTypes || !_.isArray(options.deny.contentTypes)) {\n      options.deny.contentTypes = [];\n    }\n\n    this._filter = options;\n  },\n  fileIsAllowed: function(fileRecord) {\n    var self = this;\n    if (!self._filter) {\n      return true;\n    }\n    if (!fileRecord || !fileRecord.contentType || !fileRecord.filename) {\n      throw new Error(\"invalid fileRecord:\", fileRecord);\n    }\n    var fileSize = fileRecord.size || parseInt(fileRecord.length, 10);\n    if (!fileSize || isNaN(fileSize)) {\n      throw new Error(\"invalid fileRecord file size:\", fileRecord);\n    }\n    var filter = self._filter;\n    if (filter.maxSize && fileSize > filter.maxSize) {\n      self.dispatch('invalid', { maxFileSizeExceeded: true }, fileRecord);\n      return false;\n    }\n    var saveAllFileExtensions = (filter.allow.extensions.length === 0);\n    var saveAllContentTypes = (filter.allow.contentTypes.length === 0);\n    var ext = getFileExtension(fileRecord.filename);\n    var contentType = fileRecord.contentType;\n    if (!((saveAllFileExtensions ||\n            _.indexOf(filter.allow.extensions, ext) !== -1) &&\n            _.indexOf(filter.deny.extensions, ext) === -1)) {\n      self.dispatch('invalid', { disallowedExtension: true }, fileRecord);\n      return false;\n    }\n    if (!((saveAllContentTypes ||\n            contentTypeInList(filter.allow.contentTypes, contentType)) &&\n            !contentTypeInList(filter.deny.contentTypes, contentType))) {\n      self.dispatch('invalid', { disallowedContentType: true }, fileRecord);\n      return false;\n    }\n    return true;\n  },\n  events: function (events) {\n    var self = this;\n    _.extend(self._events, events);\n  },\n  dispatch: function (/* arguments */) {\n    var self = this, args = _.toArray(arguments);\n    var eventName = args.shift();\n    self._events[eventName].apply(self, args);\n  }\n});\n\n_.extend(_queueCollectionFS.prototype, {\n\tqueue: {},\n\tchunkSize: 256 * 1024,    //gridFS default is 256kb = 262.144bytes\n\tcompareFile: function(fileRecordA, fileRecordB) {\n\t\tvar errors = 0;\n\t\tvar leaveOutField = {\n      '_id': true,\n      'uploadDate': true,\n      'currentChunk': true,\n      'fileHandler': true\n    };\n\t\tfor (var fieldName in fileRecordA) {\n\t\t\tif (!leaveOutField[fieldName]) {\n\t\t\t\tif (fileRecordA[fieldName] !== fileRecordB[fieldName]) {\n\t\t\t\t\terrors++;\n\t\t\t\t\tconsole.log(fieldName);\n\t\t\t\t}\n\t\t\t}\n\t\t} //EO for\n\t\treturn (errors === 0);\n\t},\n\tmakeGridFSFileRecord: function(file, metadata) {\n\t\tvar self = this;\n\t\tvar countChunks = Math.ceil(file.size / self.chunkSize);\n\t\tvar userId = (Meteor.isClient)?\n\t\t\t\t\t\t( (this.userId) ? this.userId: Meteor.userId() ): file.owner;\n\t\tvar encoding = (file.encoding && file.encoding !== '') ?\n            file.encoding : 'utf-8';\n\n\t\treturn {\n      chunkSize : self.chunkSize,\t// Default 256kb ~ 262.144 bytes\n      uploadDate : Date.now(),\t\t// Client/Server set date\n      handledAt: null,            // datetime set by Server when handled\n      fileHandler: {},            // fileHandler supplied data if any\n      md5 : null,                 // Not yet implemented\n      complete : false,           // countChunks == numChunks\n      currentChunk: -1,           // Used to coordinate clients\n      owner: userId,\n      countChunks: countChunks,\t\t// Expected number of chunks\n      numChunks: 0,               // number of chunks in database\n      filename : file.name,       // Original filename\n      length: ''+file.size,       // Issue in Meteor, when solved dont use ''+\n      contentType : file.type,\n      encoding: encoding,\t\t\t// Default 'utf-8'\n      metadata : (metadata) ? metadata : null // Custom data\n      /* TODO:\n      startedAt: null,          // Start timer for upload start\n      endedAt: null,            // Stop timer for upload ended\n      */\n\t\t};\n\t\t// TODO: Implement md5 later, guess every chunk should have a md5...\n\t\t// TODO: checkup on gridFS date format\n\t} //EO makeGridFSFileRecord\n});\n","\"use strict\";\n\n/*\n  COMMON API\n\n  The fileObject is equal to the fileRecord + client-side api\n  This pattern will allow easier manipulation of files since we now pass\n  file objects with methods attatched.\n  In many cases we are only passed content objects with no reference to the\n  collection attached - This way we actually know were the data belongs and\n  makes operations much easier.\n\n*/\n_.extend(_fileObject.prototype, {\n  // Expect self to have the properties of fileRecord\n  // Added is self.collection for access to the collection the file belongs\n\n  // TODO: Add common file object api\n  remove: function() {\n    // TODO: Remove this file\n  },\n  getExtension: function() {\n    var extension;\n    // TODO: parse extension\n    return extension;\n  },\n  getUrl: function(filehandler) {\n    var filehandlerUrl;\n    // TODO: return url to filehandler\n    return filehandlerUrl;\n  }\n});","/*!\n * numeral.js\n * version : 1.4.9\n * author : Adam Draper\n * license : MIT\n * http://adamwdraper.github.com/Numeral-js/\n */\n\n(function() {\n\n    /************************************\n     Constants\n     ************************************/\n\n    var numeral,\n            VERSION = '1.4.9',\n            // internal storage for language config files\n            languages = {},\n            currentLanguage = 'en',\n            zeroFormat = null,\n            // check for nodeJS\n            hasModule = (typeof module !== 'undefined' && module.exports);\n\n\n    /************************************\n     Constructors\n     ************************************/\n\n\n    // Numeral prototype object\n    function Numeral(number) {\n        this._n = number;\n    }\n\n    /**\n     * Implementation of toFixed() that treats floats more like decimals\n     *\n     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n     * problems for accounting- and finance-related software.\n     */\n    function toFixed(value, precision, optionals) {\n        var power = Math.pow(10, precision),\n                output;\n\n        // Multiply up by precision, round accurately, then divide and use native toFixed():\n        output = (Math.round(value * power) / power).toFixed(precision);\n\n        if (optionals) {\n            var optionalsRegExp = new RegExp('0{1,' + optionals + '}$');\n            output = output.replace(optionalsRegExp, '');\n        }\n\n        return output;\n    }\n\n    /************************************\n     Formatting\n     ************************************/\n\n    // determine what type of formatting we need to do\n    function formatNumeral(n, format) {\n        var output;\n\n        // figure out what kind of format we are dealing with\n        if (format.indexOf('$') > -1) { // currency!!!!!\n            output = formatCurrency(n, format);\n        } else if (format.indexOf('%') > -1) { // percentage\n            output = formatPercentage(n, format);\n        } else if (format.indexOf(':') > -1) { // time\n            output = formatTime(n, format);\n        } else { // plain ol' numbers or bytes\n            output = formatNumber(n, format);\n        }\n\n        // return string\n        return output;\n    }\n\n    // revert to number\n    function unformatNumeral(n, string) {\n        if (string.indexOf(':') > -1) {\n            n._n = unformatTime(string);\n        } else {\n            if (string === zeroFormat) {\n                n._n = 0;\n            } else {\n                var stringOriginal = string;\n                if (languages[currentLanguage].delimiters.decimal !== '.') {\n                    string = string.replace(/\\./g, '').replace(languages[currentLanguage].delimiters.decimal, '.');\n                }\n\n                // see if abbreviations are there so that we can multiply to the correct number\n                var thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$'),\n                        millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$'),\n                        billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$'),\n                        trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$');\n\n                // see if bytes are there so that we can multiply to the correct number\n                var prefixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],\n                        bytesMultiplier = false;\n\n                for (var power = 0; power <= prefixes.length; power++) {\n                    bytesMultiplier = (string.indexOf(prefixes[power]) > -1) ? Math.pow(1024, power + 1) : false;\n\n                    if (bytesMultiplier) {\n                        break;\n                    }\n                }\n\n                // do some math to create our number\n                n._n = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * Number(((string.indexOf('(') > -1) ? '-' : '') + string.replace(/[^0-9\\.-]+/g, ''));\n\n                // round if we are talking about bytes\n                n._n = (bytesMultiplier) ? Math.ceil(n._n) : n._n;\n            }\n        }\n        return n._n;\n    }\n\n    function formatCurrency(n, format) {\n        var prependSymbol = (format.indexOf('$') <= 1) ? true : false;\n\n        // remove $ for the moment\n        var space = '';\n\n        // check for space before or after currency\n        if (format.indexOf(' $') > -1) {\n            space = ' ';\n            format = format.replace(' $', '');\n        } else if (format.indexOf('$ ') > -1) {\n            space = ' ';\n            format = format.replace('$ ', '');\n        } else {\n            format = format.replace('$', '');\n        }\n\n        // format the number\n        var output = formatNumeral(n, format);\n\n        // position the symbol\n        if (prependSymbol) {\n            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {\n                output = output.split('');\n                output.splice(1, 0, languages[currentLanguage].currency.symbol + space);\n                output = output.join('');\n            } else {\n                output = languages[currentLanguage].currency.symbol + space + output;\n            }\n        } else {\n            if (output.indexOf(')') > -1) {\n                output = output.split('');\n                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);\n                output = output.join('');\n            } else {\n                output = output + space + languages[currentLanguage].currency.symbol;\n            }\n        }\n\n        return output;\n    }\n\n    function formatPercentage(n, format) {\n        var space = '';\n        // check for space before %\n        if (format.indexOf(' %') > -1) {\n            space = ' ';\n            format = format.replace(' %', '');\n        } else {\n            format = format.replace('%', '');\n        }\n\n        n._n = n._n * 100;\n        var output = formatNumeral(n, format);\n        if (output.indexOf(')') > -1) {\n            output = output.split('');\n            output.splice(-1, 0, space + '%');\n            output = output.join('');\n        } else {\n            output = output + space + '%';\n        }\n        return output;\n    }\n\n    function formatTime(n, format) {\n        var hours = Math.floor(n._n / 60 / 60),\n                minutes = Math.floor((n._n - (hours * 60 * 60)) / 60),\n                seconds = Math.round(n._n - (hours * 60 * 60) - (minutes * 60));\n        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);\n    }\n\n    function unformatTime(string) {\n        var timeArray = string.split(':'),\n                seconds = 0;\n        // turn hours and minutes into seconds and add them all up\n        if (timeArray.length === 3) {\n            // hours\n            seconds = seconds + (Number(timeArray[0]) * 60 * 60);\n            // minutes\n            seconds = seconds + (Number(timeArray[1]) * 60);\n            // seconds\n            seconds = seconds + Number(timeArray[2]);\n        } else if (timeArray.length === 2) {\n            // minutes\n            seconds = seconds + (Number(timeArray[0]) * 60);\n            // seconds\n            seconds = seconds + Number(timeArray[1]);\n        }\n        return Number(seconds);\n    }\n\n    function formatNumber(n, format) {\n        var negP = false,\n                optDec = false,\n                abbr = '',\n                bytes = '',\n                ord = '',\n                abs = Math.abs(n._n);\n\n        // check if number is zero and a custom zero format has been set\n        if (n._n === 0 && zeroFormat !== null) {\n            return zeroFormat;\n        } else {\n            // see if we should use parentheses for negative number\n            if (format.indexOf('(') > -1) {\n                negP = true;\n                format = format.slice(1, -1);\n            }\n\n            // see if abbreviation is wanted\n            if (format.indexOf('a') > -1) {\n                // check for space before abbreviation\n                if (format.indexOf(' a') > -1) {\n                    abbr = ' ';\n                    format = format.replace(' a', '');\n                } else {\n                    format = format.replace('a', '');\n                }\n\n                if (abs >= Math.pow(10, 12)) {\n                    // trillion\n                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;\n                    n._n = n._n / Math.pow(10, 12);\n                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9)) {\n                    // billion\n                    abbr = abbr + languages[currentLanguage].abbreviations.billion;\n                    n._n = n._n / Math.pow(10, 9);\n                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6)) {\n                    // million\n                    abbr = abbr + languages[currentLanguage].abbreviations.million;\n                    n._n = n._n / Math.pow(10, 6);\n                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3)) {\n                    // thousand\n                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;\n                    n._n = n._n / Math.pow(10, 3);\n                }\n            }\n\n            // see if we are formatting bytes\n            if (format.indexOf('b') > -1) {\n                // check for space before\n                if (format.indexOf(' b') > -1) {\n                    bytes = ' ';\n                    format = format.replace(' b', '');\n                } else {\n                    format = format.replace('b', '');\n                }\n\n                var prefixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],\n                        min,\n                        max;\n\n                for (var power = 0; power <= prefixes.length; power++) {\n                    min = Math.pow(1024, power);\n                    max = Math.pow(1024, power + 1);\n\n                    if (n._n >= min && n._n < max) {\n                        bytes = bytes + prefixes[power];\n                        if (min > 0) {\n                            n._n = n._n / min;\n                        }\n                        break;\n                    }\n                }\n            }\n\n            // see if ordinal is wanted\n            if (format.indexOf('o') > -1) {\n                // check for space before\n                if (format.indexOf(' o') > -1) {\n                    ord = ' ';\n                    format = format.replace(' o', '');\n                } else {\n                    format = format.replace('o', '');\n                }\n\n                ord = ord + languages[currentLanguage].ordinal(n._n);\n            }\n\n            if (format.indexOf('[.]') > -1) {\n                optDec = true;\n                format = format.replace('[.]', '.');\n            }\n\n            var w = n._n.toString().split('.')[0],\n                    precision = format.split('.')[1],\n                    thousands = format.indexOf(','),\n                    d = '',\n                    neg = false;\n\n            if (precision) {\n                if (precision.indexOf('[') > -1) {\n                    precision = precision.replace(']', '');\n                    precision = precision.split('[');\n                    d = toFixed(n._n, (precision[0].length + precision[1].length), precision[1].length);\n                } else {\n                    d = toFixed(n._n, precision.length);\n                }\n\n                w = d.split('.')[0];\n\n                if (d.split('.')[1].length) {\n                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];\n                } else {\n                    d = '';\n                }\n\n                if (optDec && Number(d.slice(1)) === 0) {\n                    d = '';\n                }\n            } else {\n                w = toFixed(n._n, null);\n            }\n\n            // format number\n            if (w.indexOf('-') > -1) {\n                w = w.slice(1);\n                neg = true;\n            }\n\n            if (thousands > -1) {\n                w = w.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);\n            }\n\n            if (format.indexOf('.') === 0) {\n                w = '';\n            }\n\n            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');\n        }\n    }\n\n    /************************************\n     Top Level Functions\n     ************************************/\n\n    numeral = function(input) {\n        if (numeral.isNumeral(input)) {\n            input = input.value();\n        } else if (!Number(input)) {\n            input = 0;\n        }\n\n        return new Numeral(Number(input));\n    };\n\n    // version number\n    numeral.version = VERSION;\n\n    // compare numeral object\n    numeral.isNumeral = function(obj) {\n        return obj instanceof Numeral;\n    };\n\n    // This function will load languages and then set the global language.  If\n    // no arguments are passed in, it will simply return the current global\n    // language key.\n    numeral.language = function(key, values) {\n        if (!key) {\n            return currentLanguage;\n        }\n\n        if (key && !values) {\n            if (!languages[key]) {\n                throw new Error('Unknown language : ' + key);\n            }\n            currentLanguage = key;\n        }\n\n        if (values || !languages[key]) {\n            loadLanguage(key, values);\n        }\n\n        return numeral;\n    };\n\n    numeral.language('en', {\n        delimiters: {\n            thousands: ',',\n            decimal: '.'\n        },\n        abbreviations: {\n            thousand: 'k',\n            million: 'm',\n            billion: 'b',\n            trillion: 't'\n        },\n        ordinal: function(number) {\n            var b = number % 10;\n            return (~~(number % 100 / 10) === 1) ? 'th' :\n                    (b === 1) ? 'st' :\n                    (b === 2) ? 'nd' :\n                    (b === 3) ? 'rd' : 'th';\n        },\n        currency: {\n            symbol: '$'\n        }\n    });\n\n    numeral.zeroFormat = function(format) {\n        if (typeof(format) === 'string') {\n            zeroFormat = format;\n        } else {\n            zeroFormat = null;\n        }\n    };\n\n    /************************************\n     Helpers\n     ************************************/\n\n    function loadLanguage(key, values) {\n        languages[key] = values;\n    }\n\n\n    /************************************\n     Numeral Prototype\n     ************************************/\n\n\n    numeral.fn = Numeral.prototype = {\n        clone: function() {\n            return numeral(this);\n        },\n        format: function(inputString) {\n            return formatNumeral(this, inputString ? inputString : numeral.defaultFormat);\n        },\n        unformat: function(inputString) {\n            return unformatNumeral(this, inputString ? inputString : numeral.defaultFormat);\n        },\n        value: function() {\n            return this._n;\n        },\n        valueOf: function() {\n            return this._n;\n        },\n        set: function(value) {\n            this._n = Number(value);\n            return this;\n        },\n        add: function(value) {\n            this._n = this._n + Number(value);\n            return this;\n        },\n        subtract: function(value) {\n            this._n = this._n - Number(value);\n            return this;\n        },\n        multiply: function(value) {\n            this._n = this._n * Number(value);\n            return this;\n        },\n        divide: function(value) {\n            this._n = this._n / Number(value);\n            return this;\n        },\n        difference: function(value) {\n            var difference = this._n - Number(value);\n\n            if (difference < 0) {\n                difference = -difference;\n            }\n\n            return difference;\n        }\n\n    };\n\n    /************************************\n     Exposing Numeral\n     ************************************/\n\n    // CommonJS module is defined\n    if (hasModule) {\n        module.exports = numeral;\n    }\n\n    /*global ender:false */\n    if (typeof ender === 'undefined') {\n        // here, `this` means `window` in the browser, or `global` on the server\n        // add `numeral` as a global object via a string identifier,\n        // for Closure Compiler 'advanced' mode\n        this['numeral'] = numeral;\n    }\n\n    /*global define:false */\n    if (typeof define === 'function' && define.amd) {\n        define([], function() {\n            return numeral;\n        });\n    }\n}).call(this);"]}