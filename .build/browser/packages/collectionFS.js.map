{"version":3,"file":"/packages/collectionFS.js","sources":["collectionFS/myConsole.js","collectionFS/FileSaver.js","collectionFS/collectionFS_templates.html","collectionFS/collectionFS_client.js","collectionFS/collectionFS_client.api.js","collectionFS/collectionFS_client.api.fileobject.js","collectionFS/collectionFS_handlebars.js","collectionFS/collectionFS_utillity.js","collectionFS/collectionFS_common.js","collectionFS/collectionFS_common.api.fileobject.js","collectionFS/numeral.js"],"names":[],"mappings":";;;;;;;;AAAA,4E;;AAEA,6C;AACA,uB;AACA,2B;AACA,kB;;AAEA,yB;AACA,6B;AACA,C;;AAEA,kD;;AAEA,iB;AACA,0B;AACA,c;AACA,wB;AACA,iE;AACA,G;AACA,E;AACA,E;;AAEA,6B;;AAEA,+B;AACA,iD;AACA,wB;AACA,Y;AACA,gD;AACA,0C;AACA,2B;AACA,8E;AACA,0C;AACA,gC;AACA,M;AACA,K;AACA,I;;AAEA,W;AACA,gC;AACA,C;;AAEA,+B;;AAEA,sB;;AAEA,W;AACA,0C;AACA,+D;AACA,sB;;AAEA,iB;AACA,uB;AACA,gC;AACA,wE;AACA,G;AACA,I;AACA,C;;;;;;;;;;;;;;;;;;;ACzDA,e;AACA,uC;AACA,a;AACA,E;AACA,kC;AACA,mB;AACA,mB;AACA,G;;AAEA,gB;AACA,0F;AACA,mB;;AAEA,mF;;AAEA,6B;AACA,mE;AACA,sB;AACA,c;AACA,I;AACA,uB;AACA,kF;AACA,0B;AACA,6C;AACA,G;AACA,4C;AACA,wE;AACA,+C;AACA,4B;AACA,8C;AACA,wB;AACA,6C;AACA,yC;AACA,K;AACA,6B;AACA,G;AACA,gD;AACA,iF;AACA,mC;AACA,sD;AACA,a;AACA,S;AACA,G;AACA,oD;AACA,mB;AACA,uB;AACA,yC;AACA,iC;AACA,gB;AACA,iC;AACA,4D;AACA,+B;AACA,8B;AACA,mB;AACA,K;AACA,I;AACA,4C;AACA,G;AACA,wD;AACA,wC;AACA,8B;AACA,gB;AACA,oD;AACA,yC;AACA,U;AACA,mD;AACA,mB;AACA,wB;AACA,M;AACA,K;AACA,I;AACA,G;AACA,sC;AACA,iE;AACA,M;AACA,sB;AACA,sB;AACA,0B;AACA,gB;AACA,iB;AACA,mC;AACA,sD;AACA,qC;AACA,uB;AACA,K;AACA,iC;AACA,0E;AACA,K;AACA,8D;AACA,6B;AACA,iD;AACA,uC;AACA,wC;AACA,M;AACA,uB;AACA,6C;AACA,a;AACA,0D;AACA,qB;AACA,2C;AACA,oB;AACA,K;AACA,kC;AACA,wB;AACA,oD;AACA,0C;AACA,O;AACA,O;AACA,K;AACA,4D;AACA,W;AACA,I;AACA,yC;AACA,e;AACA,sB;AACA,I;AACA,2B;AACA,sC;AACA,gC;AACA,8B;AACA,qB;AACA,0C;AACA,mB;AACA,W;AACA,I;AACA,gF;AACA,oE;AACA,8D;AACA,6D;AACA,2C;AACA,+D;AACA,wB;AACA,I;AACA,+E;AACA,oD;AACA,mD;AACA,8C;AACA,wB;AACA,I;AACA,uD;AACA,uB;AACA,I;AACA,iB;AACA,e;AACA,W;AACA,I;AACA,4B;AACA,+D;AACA,gF;AACA,4B;AACA,uE;AACA,qD;AACA,6C;AACA,kD;AACA,mC;AACA,+C;AACA,gD;AACA,U;AACA,qC;AACA,kC;AACA,8C;AACA,qB;AACA,U;AACA,U;AACA,8E;AACA,wD;AACA,W;AACA,2B;AACA,sC;AACA,wB;AACA,+C;AACA,U;AACA,iD;AACA,qB;AACA,oB;AACA,O;AACA,kE;AACA,yC;AACA,oB;AACA,a;AACA,iC;AACA,yC;AACA,c;AACA,c;AACA,kB;AACA,O;AACA,S;AACA,kB;AACA,iB;AACA,G;AACA,kC;AACA,mC;AACA,oC;AACA,G;AACA,E;AACA,8B;AACA,uB;AACA,wC;AACA,+B;AACA,G;AACA,yC;AACA,sB;AACA,mB;;AAEA,iB;AACA,wB;AACA,sB;AACA,mB;AACA,mB;AACA,mB;AACA,sB;AACA,O;;AAEA,gE;AACA,e;AACA,S;;;;;;;;;;;;;;;;;;ACvNA,gU;AACA,qL;AACA,yO;;;;;;;;;;;;;;;;;;;ACFA,kB;AACA,gC;AACA,a;AACA,E;AACA,0C;AACA,E;AACA,G;;AAEA,kC;AACA,yC;AACA,kB;AACA,+B;AACA,sB;AACA,E;;AAEA,uB;AACA,wC;AACA,c;AACA,iB;AACA,mB;AACA,qB;AACA,kC;AACA,0D;AACA,8B;AACA,wC;AACA,K;AACA,K;AACA,6B;AACA,6D;AACA,2C;AACA,uC;AACA,kC;;AAEA,Y;AACA,iB;AACA,2B;AACA,mE;AACA,6D;AACA,2B;AACA,0B;AACA,2B;AACA,I;;AAEA,iB;AACA,gC;AACA,0C;AACA,G;;AAEA,oB;;AAEA,qC;AACA,e;AACA,iB;AACA,mB;AACA,wC;AACA,oD;AACA,4E;AACA,sD;AACA,yD;AACA,qB;AACA,E;;;;;;;;;;;;;;;;;;;AC5DA,a;;AAEA,kC;AACA,qC;AACA,kB;AACA,oB;AACA,8D;AACA,sC;AACA,kB;AACA,K;AACA,qC;AACA,gB;AACA,kB;AACA,K;AACA,4B;AACA,mC;AACA,gB;AACA,kB;AACA,mD;AACA,wD;AACA,gC;AACA,uD;AACA,wB;AACA,uE;AACA,kC;AACA,gB;AACA,4B;AACA,S;AACA,8C;AACA,qB;AACA,+B;AACA,S;AACA,uE;AACA,iC;AACA,S;AACA,O;AACA,K;AACA,mB;AACA,oB;AACA,qB;AACA,2C;AACA,gC;AACA,kB;AACA,6C;AACA,sE;AACA,kD;AACA,oB;AACA,sB;AACA,U;AACA,uD;AACA,kC;AACA,4C;AACA,G;AACA,e;AACA,qB;AACA,2C;AACA,8C;AACA,yE;AACA,oB;AACA,uE;AACA,iC;AACA,oC;AACA,+B;AACA,4B;AACA,2B;AACA,K;;AAEA,0B;AACA,2B;AACA,uB;AACA,kE;AACA,K;;AAEA,kD;AACA,iD;AACA,iD;AACA,gD;AACA,yC;;AAEA,0C;AACA,G;AACA,0B;;;AAGA,wC;;AAEA,+E;AACA,+E;AACA,+E;;AAEA,4B;AACA,kB;AACA,yB;AACA,+B;AACA,gB;;AAEA,6C;AACA,6B;AACA,kB;AACA,4B;AACA,iB;;AAEA,kD;AACA,8C;AACA,oB;AACA,yC;AACA,oB;AACA,mB;AACA,K;;AAEA,4B;AACA,iB;AACA,K;;AAEA,qC;AACA,wE;;AAEA,mB;AACA,mE;AACA,Y;AACA,e;AACA,K;AACA,sB;;AAEA,yC;AACA,kB;AACA,2B;AACA,iD;AACA,iB;;AAEA,+B;AACA,oB;AACA,2B;AACA,yC;AACA,oB;AACA,kB;AACA,K;AACA,6B;AACA,mB;;AAEA,iC;AACA,oB;AACA,2B;AACA,yC;AACA,yC;AACA,mB;AACA,K;AACA,6C;AACA,wD;AACA,qB;;AAEA,kC;AACA,kB;AACA,2B;AACA,uC;AACA,wC;AACA,mB;AACA,K;AACA,6C;AACA,wD;AACA,sB;;AAEA,iC;AACA,kB;AACA,yB;AACA,uC;AACA,sB;AACA,kB;AACA,K;AACA,0B;AACA,6D;AACA,G;AACA,e;AACA,qB;;AAEA,uB;AACA,kB;AACA,yB;AACA,qB;AACA,iB;;;AAGA,+E;AACA,+E;AACA,+E;AACA,sD;AACA,qB;AACA,kB;AACA,sB;AACA,0B;AACA,uC;AACA,kC;AACA,wC;AACA,2B;AACA,mB;AACA,sB;AACA,qC;AACA,gB;AACA,4C;AACA,mE;AACA,W;AACA,S;AACA,W;AACA,mB;AACA,uB;AACA,+B;AACA,Y;AACA,iD;AACA,kE;AACA,W;AACA,S;AACA,I;AACA,G;AACA,e;;AAEA,oB;AACA,qB;AACA,0B;AACA,G;;AAEA,yC;AACA,kB;AACA,uD;AACA,qD;AACA,+D;AACA,e;AACA,G;AACA,iD;AACA,iD;AACA,iB;AACA,+E;AACA,+E;AACA,+E;AACA,qD;AACA,kB;AACA,uC;;AAEA,mB;AACA,0C;AACA,qC;AACA,K;;AAEA,uE;AACA,yC;AACA,G;;AAEA,oC;AACA,kB;AACA,uC;;AAEA,6D;AACA,yC;AACA,2D;AACA,8C;AACA,sC;AACA,2B;AACA,iD;AACA,sC;AACA,I;AACA,kC;AACA,2B;AACA,G;AACA,G;;AAEA,kD;AACA,kB;AACA,uC;AACA,+D;AACA,gC;AACA,gB;AACA,K;;AAEA,2B;AACA,8B;AACA,uC;AACA,+B;AACA,sD;AACA,4D;AACA,oE;AACA,iE;AACA,mC;AACA,6E;AACA,uC;AACA,I;AACA,U;AACA,sC;AACA,G;;AAEA,+D;AACA,mB;AACA,+B;AACA,qC;AACA,K;AACA,c;AACA,I;AACA,4B;AACA,c;AACA,yB;;AAEA,mE;AACA,2D;AACA,uC;AACA,wD;AACA,gB;AACA,uC;AACA,a;AACA,mD;AACA,qD;AACA,oC;AACA,iB;AACA,kD;AACA,S;AACA,oC;;AAEA,uD;AACA,+B;AACA,S;AACA,M;AACA,K;AACA,a;AACA,qB;AACA,Q;;AAEA,8B;AACA,wD;AACA,kB;AACA,gC;AACA,uB;AACA,kB;AACA,mB;AACA,c;AACA,c;AACA,mB;AACA,6B;AACA,oC;AACA,8B;AACA,uC;AACA,qD;AACA,+C;AACA,6C;AACA,0C;AACA,sB;AACA,4B;AACA,qE;;AAEA,I;;AAEA,uC;AACA,0B;;AAEA,iB;AACA,qB;AACA,sC;AACA,U;AACA,0C;AACA,uE;AACA,O;AACA,K;AACA,Q;AACA,+E;AACA,+E;AACA,+E;;AAEA,gD;AACA,kB;AACA,0D;AACA,wB;AACA,e;AACA,mB;AACA,mB;AACA,c;AACA,0B;AACA,6B;AACA,8B;AACA,qD;AACA,+C;AACA,6C;AACA,2B;AACA,kC;AACA,I;AACA,qC;AACA,0B;;AAEA,iB;AACA,qB;AACA,gC;AACA,U;AACA,0C;AACA,0D;AACA,O;AACA,K;AACA,gB;;AAEA,iD;AACA,kB;AACA,+D;AACA,gC;AACA,gB;AACA,K;AACA,kC;AACA,kC;AACA,6C;AACA,qC;AACA,sD;AACA,iD;AACA,uD;;AAEA,sC;AACA,mD;AACA,+D;AACA,I;AACA,I;;AAEA,a;AACA,qC;AACA,U;AACA,mE;AACA,G;AACA,uB;;AAEA,mD;AACA,kB;AACA,uC;;AAEA,yB;AACA,4B;AACA,qC;AACA,6B;AACA,oD;AACA,0D;AACA,4D;AACA,6D;AACA,iC;AACA,yE;AACA,qC;AACA,I;AACA,U;AACA,oC;AACA,G;;AAEA,+D;AACA,mB;AACA,8B;AACA,sC;AACA,c;AACA,K;AACA,c;AACA,8B;AACA,c;AACA,gB;AACA,6B;AACA,S;;AAEA,yB;AACA,iE;;AAEA,0D;AACA,iC;AACA,gD;AACA,mC;AACA,qE;AACA,sE;AACA,sD;AACA,O;AACA,2E;AACA,iD;;AAEA,qE;AACA,0B;AACA,4B;AACA,6C;AACA,e;AACA,uC;;AAEA,Q;AACA,K;AACA,I;;AAEA,I;AACA,qB;AACA,qC;AACA,8B;AACA,kB;AACA,uB;AACA,mB;AACA,K;AACA,mE;AACA,+B;AACA,+E;AACA,sB;AACA,sD;AACA,4C;AACA,4B;AACA,oC;AACA,S;AACA,+B;AACA,gB;AACA,U;AACA,2E;AACA,+B;AACA,4C;AACA,G;AACA,iB;;;AAGA,Q;;;;;;;;;;;;;;;;;;;ACzfA,a;;;AAGA,E;AACA,Y;;AAEA,mE;AACA,wE;AACA,sC;AACA,2E;AACA,2E;AACA,+B;;AAEA,K;;AAEA,wB;AACA,0C;AACA,iB;AACA,sB;AACA,mB;AACA,mB;AACA,yB;AACA,mB;AACA,K;AACA,K;;AAEA,E;AACA,iC;AACA,qD;AACA,2E;;AAEA,qC;AACA,iC;AACA,yC;AACA,iE;AACA,K;;AAEA,a;;AAEA,mD;;AAEA,mB;AACA,I;AACA,8B;AACA,yC;AACA,8D;AACA,K;;AAEA,a;;AAEA,0C;;AAEA,mB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;ACtDA,a;;AAEA,wC;AACA,U;AACA,mC;AACA,qE;AACA,8C;AACA,K;;AAEA,U;AACA,6B;AACA,8D;AACA,qC;AACA,K;;AAEA,U;AACA,oC;AACA,iE;AACA,iD;AACA,K;;AAEA,U;AACA,sE;AACA,iD;AACA,qD;AACA,0E;AACA,0B;AACA,8C;AACA,oB;AACA,6B;AACA,Y;AACA,uC;AACA,K;AACA,kB;AACA,mB;AACA,K;AACA,6B;AACA,6B;AACA,mB;AACA,K;AACA,yC;AACA,K;;AAEA,U;AACA,wE;AACA,mD;AACA,uD;AACA,4E;AACA,0B;AACA,8C;AACA,oB;AACA,6B;AACA,Y;AACA,uC;AACA,K;AACA,kB;AACA,mB;AACA,K;AACA,6B;AACA,6B;AACA,mB;AACA,K;AACA,2C;AACA,K;;AAEA,U;AACA,uE;AACA,kD;AACA,sD;AACA,2E;AACA,0B;AACA,8C;AACA,oB;AACA,6B;AACA,Y;AACA,uC;AACA,K;AACA,kB;AACA,mB;AACA,K;AACA,6B;AACA,6B;AACA,mB;AACA,K;AACA,0C;AACA,K;;AAEA,U;AACA,qE;AACA,gD;AACA,oD;AACA,yE;AACA,0B;AACA,8C;AACA,oB;AACA,6B;AACA,Y;AACA,uC;AACA,K;AACA,kB;AACA,mB;AACA,K;AACA,6B;AACA,6B;AACA,mB;AACA,K;AACA,wC;AACA,K;;AAEA,U;AACA,wE;AACA,mD;AACA,uD;AACA,4E;AACA,0B;AACA,8C;AACA,oB;AACA,6B;AACA,Y;AACA,uC;AACA,K;AACA,kB;AACA,mB;AACA,K;AACA,6B;AACA,6B;AACA,mB;AACA,K;AACA,sC;AACA,K;;AAEA,U;AACA,2E;AACA,sD;AACA,0D;AACA,gC;AACA,+E;AACA,qB;AACA,8C;AACA,oB;AACA,6B;AACA,Y;AACA,uC;AACA,K;AACA,kB;AACA,mB;AACA,K;AACA,oE;AACA,6B;AACA,qB;AACA,0E;AACA,iD;AACA,Q;AACA,K;;AAEA,U;AACA,gC;AACA,iE;AACA,iC;AACA,6B;AACA,mB;AACA,K;AACA,gC;AACA,K;;AAEA,uC;AACA,qD;AACA,gC;AACA,4D;AACA,2C;AACA,mE;AACA,8C;AACA,0E;AACA,0D;AACA,2B;AACA,8C;AACA,4C;AACA,yC;AACA,0D;AACA,K;AACA,gB;AACA,+B;AACA,K;AACA,gB;AACA,mB;AACA,K;AACA,mC;AACA,K;;AAEA,kC;AACA,2D;AACA,sC;AACA,kE;AACA,0D;AACA,sD;AACA,0C;AACA,gE;AACA,gE;AACA,uC;AACA,gE;AACA,iC;AACA,8C;AACA,yC;AACA,0D;AACA,K;AACA,gB;AACA,+B;AACA,K;AACA,gB;AACA,uB;AACA,K;AACA,iD;AACA,qD;AACA,K;;AAEA,U;AACA,0D;AACA,qC;AACA,iE;AACA,+D;AACA,+C;AACA,8C;AACA,yC;AACA,0D;AACA,K;AACA,gB;AACA,+B;AACA,K;AACA,qC;AACA,0B;AACA,K;AACA,gC;AACA,mC;AACA,6B;AACA,K;AACA,wB;AACA,K;;AAEA,U;AACA,sE;AACA,iD;AACA,6E;AACA,uE;AACA,uB;AACA,8C;AACA,yC;AACA,0D;AACA,K;AACA,gB;AACA,+B;AACA,K;AACA,qC;AACA,gB;AACA,K;AACA,uC;AACA,c;AACA,gB;AACA,K;AACA,kB;AACA,K;;AAEA,U;AACA,yE;AACA,oD;AACA,wD;AACA,yC;AACA,6E;AACA,2B;AACA,8C;AACA,oB;AACA,6B;AACA,Y;AACA,uC;AACA,K;AACA,kB;AACA,mB;AACA,K;AACA,iE;AACA,gC;AACA,mE;AACA,gD;AACA,8C;AACA,kE;AACA,6B;AACA,qB;AACA,4B;AACA,sB;AACA,Q;AACA,K;;AAEA,sC;AACA,2D;AACA,wC;AACA,yD;AACA,mC;AACA,qB;AACA,O;AACA,+B;AACA,+B;AACA,qB;AACA,O;AACA,mD;AACA,4B;AACA,0D;AACA,gB;AACA,0D;AACA,S;AACA,S;AACA,K;AACA,K;;AAEA,2C;AACA,iC;AACA,uD;AACA,8B;AACA,2B;AACA,gD;AACA,wC;AACA,8C;AACA,0C;AACA,iB;AACA,wC;AACA,kB;AACA,uD;AACA,kC;AACA,8C;AACA,uC;AACA,mB;AACA,W;AACA,0D;AACA,iD;;AAEA,yB;AACA,2C;AACA,kB;AACA,6B;AACA,gD;AACA,oB;AACA,8C;AACA,a;AACA,W;AACA,kE;AACA,S;AACA,O;AACA,K;AACA,K;;AAEA,iB;AACA,2E;AACA,gD;AACA,wB;AACA,kB;AACA,gF;AACA,uE;AACA,qD;AACA,gE;AACA,mD;AACA,uC;AACA,iC;AACA,kC;AACA,sC;AACA,wC;AACA,0B;AACA,W;AACA,c;AACA,mB;AACA,c;AACA,c;AACA,K;AACA,2C;AACA,K;AACA,Q;AACA,+B;AACA,C;;;;;;;;;;;;;;;;;;;ACrXA,a;;AAEA,mB;AACA,kD;AACA,mC;AACA,wC;AACA,+C;AACA,E;;AAEA,iD;AACA,8B;AACA,kD;AACA,0C;AACA,mC;AACA,mB;AACA,Y;AACA,K;AACA,wE;AACA,mB;AACA,Y;AACA,K;AACA,wE;AACA,mB;AACA,Y;AACA,K;AACA,wE;AACA,mB;AACA,Y;AACA,K;AACA,G;AACA,e;AACA,E;;AAEA,0C;AACA,gB;AACA,sC;AACA,qC;AACA,iB;AACA,G;AACA,6B;AACA,wC;AACA,a;AACA,G;AACA,wB;AACA,2B;AACA,uB;AACA,8B;AACA,0C;AACA,e;AACA,K;AACA,wB;AACA,4E;AACA,oB;AACA,K;AACA,mB;AACA,G;AACA,iE;AACA,E;;AAEA,wB;AACA,sD;AACA,uB;AACA,qC;AACA,sE;AACA,E;AACA,E;AACA,2C;AACA,mB;AACA,sB;AACA,C;AACA,E;;AAEA,gE;AACA,+B;AACA,6C;AACA,wC;AACA,E;;AAEA,6C;AACA,uB;AACA,qC;AACA,gC;AACA,E;;AAEA,+B;AACA,yC;AACA,oB;AACA,E;;;;;;;;;;;;;;;;;;;ACvFA,a;;AAEA,uD;AACA,kC;AACA,mB;AACA,wD;AACA,I;AACA,sB;AACA,2D;AACA,I;AACA,qB;AACA,0D;AACA,I;AACA,qB;AACA,0D;AACA,I;AACA,oB;AACA,yD;AACA,I;AACA,mB;AACA,wD;AACA,I;AACA,kC;AACA,0C;AACA,I;AACA,6B;AACA,mC;AACA,+D;AACA,yB;AACA,K;AACA,6D;AACA,wB;AACA,K;AACA,2D;AACA,8B;AACA,K;AACA,4E;AACA,oC;AACA,K;AACA,gF;AACA,sC;AACA,K;AACA,0E;AACA,mC;AACA,K;AACA,8E;AACA,qC;AACA,K;;AAEA,2B;AACA,I;AACA,uC;AACA,oB;AACA,wB;AACA,kB;AACA,K;AACA,yE;AACA,yD;AACA,K;AACA,sE;AACA,uC;AACA,mE;AACA,K;AACA,8B;AACA,sD;AACA,0E;AACA,mB;AACA,K;AACA,uE;AACA,uE;AACA,oD;AACA,6C;AACA,mC;AACA,8D;AACA,6D;AACA,0E;AACA,mB;AACA,K;AACA,iC;AACA,yE;AACA,yE;AACA,4E;AACA,mB;AACA,K;AACA,gB;AACA,I;AACA,6B;AACA,oB;AACA,mC;AACA,I;AACA,wC;AACA,iD;AACA,iC;AACA,8C;AACA,G;AACA,G;;AAEA,wC;AACA,W;AACA,mE;AACA,kD;AACA,iB;AACA,uB;AACA,kB;AACA,yB;AACA,2B;AACA,yB;AACA,M;AACA,sC;AACA,mC;AACA,4D;AACA,c;AACA,4B;AACA,K;AACA,I;AACA,Y;AACA,wB;AACA,G;AACA,iD;AACA,kB;AACA,0D;AACA,iC;AACA,mE;AACA,0D;AACA,oC;;AAEA,U;AACA,kE;AACA,yD;AACA,wE;AACA,qE;AACA,wD;AACA,6D;AACA,+D;AACA,oB;AACA,6D;AACA,iE;AACA,sD;AACA,8E;AACA,8B;AACA,8C;AACA,4D;AACA,c;AACA,+D;AACA,8D;AACA,Q;AACA,I;AACA,sE;AACA,wC;AACA,4B;AACA,G;;;;;;;;;;;;;;;;;;;ACtJA,a;;AAEA,E;AACA,Y;;AAEA,6D;AACA,wE;AACA,sC;AACA,2E;AACA,2E;AACA,+B;;AAEA,E;AACA,iC;AACA,qD;AACA,2E;;AAEA,qC;AACA,sB;AACA,6B;AACA,I;AACA,4B;AACA,kB;AACA,4B;AACA,qB;AACA,I;AACA,iC;AACA,uB;AACA,sC;AACA,0B;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;AC/BA,G;AACA,a;AACA,kB;AACA,uB;AACA,gB;AACA,4C;AACA,G;;AAEA,a;;AAEA,yC;AACA,c;AACA,0C;;AAEA,gB;AACA,8B;AACA,yD;AACA,2B;AACA,mC;AACA,8B;AACA,+B;AACA,0E;;;AAGA,yC;AACA,iB;AACA,0C;;;AAGA,+B;AACA,8B;AACA,yB;AACA,K;;AAEA,O;AACA,wE;AACA,M;AACA,oF;AACA,6D;AACA,O;AACA,mD;AACA,4C;AACA,uB;;AAEA,4F;AACA,wE;;AAEA,wB;AACA,wE;AACA,yD;AACA,S;;AAEA,sB;AACA,K;;AAEA,yC;AACA,e;AACA,0C;;AAEA,sD;AACA,uC;AACA,mB;;AAEA,6D;AACA,wD;AACA,+C;AACA,4D;AACA,iD;AACA,sD;AACA,2C;AACA,8C;AACA,6C;AACA,S;;AAEA,wB;AACA,sB;AACA,K;;AAEA,uB;AACA,yC;AACA,uC;AACA,wC;AACA,gB;AACA,wC;AACA,yB;AACA,oB;AACA,4C;AACA,4E;AACA,mH;AACA,iB;;AAEA,+F;AACA,+L;AACA,iM;AACA,iM;AACA,mM;;AAEA,uF;AACA,gF;AACA,gD;;AAEA,wE;AACA,iH;;AAEA,0C;AACA,8B;AACA,qB;AACA,iB;;AAEA,oD;AACA,oc;;AAEA,sD;AACA,kE;AACA,a;AACA,S;AACA,oB;AACA,K;;AAEA,wC;AACA,sE;;AAEA,kC;AACA,uB;;AAEA,mD;AACA,wC;AACA,wB;AACA,8C;AACA,+C;AACA,wB;AACA,8C;AACA,gB;AACA,6C;AACA,S;;AAEA,4B;AACA,8C;;AAEA,8B;AACA,4B;AACA,uE;AACA,0C;AACA,wF;AACA,yC;AACA,oB;AACA,qF;AACA,a;AACA,gB;AACA,2C;AACA,0C;AACA,yF;AACA,yC;AACA,oB;AACA,qF;AACA,a;AACA,S;;AAEA,sB;AACA,K;;AAEA,0C;AACA,uB;AACA,mC;AACA,wC;AACA,wB;AACA,8C;AACA,gB;AACA,6C;AACA,S;;AAEA,0B;AACA,8C;AACA,uC;AACA,sC;AACA,8C;AACA,qC;AACA,gB;AACA,0C;AACA,S;AACA,sB;AACA,K;;AAEA,oC;AACA,+C;AACA,sE;AACA,gF;AACA,2H;AACA,K;;AAEA,mC;AACA,0C;AACA,4B;AACA,kE;AACA,qC;AACA,oB;AACA,iE;AACA,sB;AACA,4D;AACA,sB;AACA,qD;AACA,4C;AACA,sB;AACA,4D;AACA,sB;AACA,qD;AACA,S;AACA,+B;AACA,K;;AAEA,sC;AACA,yB;AACA,+B;AACA,0B;AACA,2B;AACA,yB;AACA,qC;;AAEA,wE;AACA,gD;AACA,8B;AACA,gB;AACA,mE;AACA,2C;AACA,4B;AACA,6C;AACA,a;;AAEA,4C;AACA,2C;AACA,sD;AACA,gD;AACA,+B;AACA,sD;AACA,wB;AACA,qD;AACA,iB;;AAEA,8C;AACA,+B;AACA,oF;AACA,mD;AACA,8E;AACA,8B;AACA,mF;AACA,kD;AACA,6E;AACA,8B;AACA,mF;AACA,kD;AACA,6E;AACA,+B;AACA,oF;AACA,kD;AACA,iB;AACA,a;;AAEA,6C;AACA,2C;AACA,yC;AACA,gD;AACA,gC;AACA,sD;AACA,wB;AACA,qD;AACA,iB;;AAEA,qF;AACA,4B;AACA,4B;;AAEA,wE;AACA,gD;AACA,oD;;AAEA,oD;AACA,wD;AACA,sC;AACA,8C;AACA,yB;AACA,8B;AACA,qB;AACA,iB;AACA,a;;AAEA,uC;AACA,2C;AACA,yC;AACA,gD;AACA,8B;AACA,sD;AACA,wB;AACA,qD;AACA,iB;;AAEA,qE;AACA,a;;AAEA,6C;AACA,8B;AACA,oD;AACA,a;;AAEA,kD;AACA,qD;AACA,oD;AACA,2B;AACA,gC;;AAEA,4B;AACA,kD;AACA,2D;AACA,qD;AACA,wG;AACA,wB;AACA,wD;AACA,iB;;AAEA,oC;;AAEA,6C;AACA,wF;AACA,wB;AACA,2B;AACA,iB;;AAEA,yD;AACA,2B;AACA,iB;AACA,oB;AACA,wC;AACA,a;;AAEA,4B;AACA,sC;AACA,+B;AACA,2B;AACA,a;;AAEA,iC;AACA,4H;AACA,a;;AAEA,4C;AACA,uB;AACA,a;;AAEA,sL;AACA,S;AACA,K;;AAEA,yC;AACA,wB;AACA,0C;;AAEA,+B;AACA,uC;AACA,kC;AACA,oC;AACA,sB;AACA,S;;AAEA,0C;AACA,M;;AAEA,qB;AACA,8B;;AAEA,6B;AACA,uC;AACA,sC;AACA,M;;AAEA,8E;AACA,2E;AACA,oB;AACA,8C;AACA,mB;AACA,mC;AACA,S;;AAEA,6B;AACA,kC;AACA,6D;AACA,a;AACA,kC;AACA,S;;AAEA,wC;AACA,sC;AACA,S;;AAEA,uB;AACA,M;;AAEA,4B;AACA,qB;AACA,2B;AACA,wB;AACA,U;AACA,wB;AACA,0B;AACA,yB;AACA,yB;AACA,yB;AACA,U;AACA,mC;AACA,gC;AACA,yD;AACA,sC;AACA,sC;AACA,4C;AACA,U;AACA,mB;AACA,uB;AACA,S;AACA,O;;AAEA,2C;AACA,0C;AACA,gC;AACA,gB;AACA,8B;AACA,S;AACA,M;;AAEA,yC;AACA,Y;AACA,0C;;AAEA,wC;AACA,gC;AACA,K;;;AAGA,yC;AACA,sB;AACA,0C;;;AAGA,sC;AACA,2B;AACA,iC;AACA,U;AACA,uC;AACA,0F;AACA,U;AACA,yC;AACA,4F;AACA,U;AACA,2B;AACA,2B;AACA,U;AACA,6B;AACA,2B;AACA,U;AACA,8B;AACA,oC;AACA,wB;AACA,U;AACA,8B;AACA,8C;AACA,wB;AACA,U;AACA,mC;AACA,8C;AACA,wB;AACA,U;AACA,mC;AACA,8C;AACA,wB;AACA,U;AACA,iC;AACA,8C;AACA,wB;AACA,U;AACA,qC;AACA,qD;;AAEA,iC;AACA,yC;AACA,a;;AAEA,8B;AACA,S;;AAEA,M;;AAEA,yC;AACA,qB;AACA,0C;;AAEA,iC;AACA,oB;AACA,iC;AACA,K;;AAEA,2B;AACA,uC;AACA,gF;AACA,oE;AACA,+C;AACA,kC;AACA,K;;AAEA,4B;AACA,qD;AACA,+B;AACA,2B;AACA,W;AACA,K;AACA,c","sourcesContent":["/* Just a simple console to get server console in client, Regz. RaiX 2013 */\n\n// Set true to get all logs from server start\nvar getAllLogs = false;\n// Enable / disable logging\nvar debug = false;\n\nif (!Meteor.Collection) {\n  console.log('No meteor??');\n}\n\nvar myConsole = new Meteor.Collection('_console');\n\nserverConsole = {\n\tlog: function (message) {\n\t\tif (debug) {\n\t\t\tconsole.log(message);\n\t\t\tmyConsole.insert({ message: message, createdAt: Date.now() });\n\t\t}\n\t}\n};\n\nvar timeConsole = Date.now();\n\nif (Meteor.isClient && debug) {\n\tMeteor.call('getTime', function(error, result) {\n\t\ttimeConsole = +result;\n\t\tif (error)\n\t\t\tconsole.log('getTime error: '+error.message);\n\t\tconsole.log('Got server time: '+result);\n\t\tDeps.autorun(function() {\n\t\t\tmyConsole.find({ createdAt: { $gt: timeConsole } }).forEach(function(doc) {\n\t\t\t\tconsole.log('SERVER: ' + doc.message);\n\t\t\t\ttimeConsole = doc.createdAt;\n\t\t\t});\n\t\t});\n\t});\n\n\tif (debug)\n\t\tMeteor.subscribe('myConsole');\n}\n\nif (Meteor.isServer && debug) {\n\n\tmyConsole.remove({});\n\n\tif (debug)\n\t\tMeteor.publish('myConsole', function() {\n\t\t\treturn myConsole.find({ createdAt : { $gt: timeConsole } });\n\t\t}, {is_auto: true});\n\n\tMeteor.methods({\n\t\tgetTime: function() {\n\t\t\tserverConsole.log('getTime');\n\t\t\treturn (getAllLogs)? 0 : Date.now()-20000; // Just add a little slack\n\t\t}\n\t});\n}\n","/* FileSaver.js\n * A saveAs() FileSaver implementation.\n * 2013-01-23\n *\n * By Eli Grey, http://eligrey.com\n * License: X11/MIT\n *   See LICENSE.md\n */\n\n/*global self */\n/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,\n  plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */\n\nwindow.saveAs = window.saveAs\n  || (navigator.msSaveBlob && navigator.msSaveBlob.bind(navigator))\n  || (function(view) {\n\t\"use strict\";\n\tvar\n\t\t  doc = view.document\n\t\t  // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet\n\t\t, get_URL = function() {\n\t\t\treturn view.URL || view.webkitURL || view;\n\t\t}\n\t\t, URL = view.URL || view.webkitURL || view\n\t\t, save_link = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\")\n\t\t, can_use_save_link = \"download\" in save_link\n\t\t, click = function(node) {\n\t\t\tvar event = doc.createEvent(\"MouseEvents\");\n\t\t\tevent.initMouseEvent(\n\t\t\t\t\"click\", true, false, view, 0, 0, 0, 0, 0\n\t\t\t\t, false, false, false, false, 0, null\n\t\t\t);\n\t\t\tnode.dispatchEvent(event);\n\t\t}\n\t\t, webkit_req_fs = view.webkitRequestFileSystem\n\t\t, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem\n\t\t, throw_outside = function (ex) {\n\t\t\t(view.setImmediate || view.setTimeout)(function() {\n\t\t\t\tthrow ex;\n\t\t\t}, 0);\n\t\t}\n\t\t, force_saveable_type = \"application/octet-stream\"\n\t\t, fs_min_size = 0\n\t\t, deletion_queue = []\n\t\t, process_deletion_queue = function() {\n\t\t\tvar i = deletion_queue.length;\n\t\t\twhile (i--) {\n\t\t\t\tvar file = deletion_queue[i];\n\t\t\t\tif (typeof file === \"string\") { // file is an object URL\n\t\t\t\t\tURL.revokeObjectURL(file);\n\t\t\t\t} else { // file is a File\n\t\t\t\t\tfile.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeletion_queue.length = 0; // clear queue\n\t\t}\n\t\t, dispatch = function(filesaver, event_types, event) {\n\t\t\tevent_types = [].concat(event_types);\n\t\t\tvar i = event_types.length;\n\t\t\twhile (i--) {\n\t\t\t\tvar listener = filesaver[\"on\" + event_types[i]];\n\t\t\t\tif (typeof listener === \"function\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlistener.call(filesaver, event || filesaver);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\tthrow_outside(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t, FileSaver = function(blob, name) {\n\t\t\t// First try a.download, then web filesystem, then object URLs\n\t\t\tvar\n\t\t\t\t  filesaver = this\n\t\t\t\t, type = blob.type\n\t\t\t\t, blob_changed = false\n\t\t\t\t, object_url\n\t\t\t\t, target_view\n\t\t\t\t, get_object_url = function() {\n\t\t\t\t\tvar object_url = get_URL().createObjectURL(blob);\n\t\t\t\t\tdeletion_queue.push(object_url);\n\t\t\t\t\treturn object_url;\n\t\t\t\t}\n\t\t\t\t, dispatch_all = function() {\n\t\t\t\t\tdispatch(filesaver, \"writestart progress write writeend\".split(\" \"));\n\t\t\t\t}\n\t\t\t\t// on any filesys errors revert to saving with object URLs\n\t\t\t\t, fs_error = function() {\n\t\t\t\t\t// don't create more object URLs than needed\n\t\t\t\t\tif (blob_changed || !object_url) {\n\t\t\t\t\t\tobject_url = get_object_url(blob);\n\t\t\t\t\t}\n\t\t\t\t\tif (target_view) {\n\t\t\t\t\t\ttarget_view.location.href = object_url;\n\t\t\t\t\t} else {\n                        window.open(object_url, \"_blank\");\n                    }\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\tdispatch_all();\n\t\t\t\t}\n\t\t\t\t, abortable = function(func) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif (filesaver.readyState !== filesaver.DONE) {\n\t\t\t\t\t\t\treturn func.apply(this, arguments);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t, create_if_not_found = {create: true, exclusive: false}\n\t\t\t\t, slice\n\t\t\t;\n\t\t\tfilesaver.readyState = filesaver.INIT;\n\t\t\tif (!name) {\n\t\t\t\tname = \"download\";\n\t\t\t}\n\t\t\tif (can_use_save_link) {\n\t\t\t\tobject_url = get_object_url(blob);\n\t\t\t\tsave_link.href = object_url;\n\t\t\t\tsave_link.download = name;\n\t\t\t\tclick(save_link);\n\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\tdispatch_all();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Object and web filesystem URLs have a problem saving in Google Chrome when\n\t\t\t// viewed in a tab, so I force save with application/octet-stream\n\t\t\t// http://code.google.com/p/chromium/issues/detail?id=91158\n\t\t\tif (view.chrome && type && type !== force_saveable_type) {\n\t\t\t\tslice = blob.slice || blob.webkitSlice;\n\t\t\t\tblob = slice.call(blob, 0, blob.size, force_saveable_type);\n\t\t\t\tblob_changed = true;\n\t\t\t}\n\t\t\t// Since I can't be sure that the guessed media type will trigger a download\n\t\t\t// in WebKit, I append .download to the filename.\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=65440\n\t\t\tif (webkit_req_fs && name !== \"download\") {\n\t\t\t\tname += \".download\";\n\t\t\t}\n\t\t\tif (type === force_saveable_type || webkit_req_fs) {\n\t\t\t\ttarget_view = view;\n\t\t\t}\n\t\t\tif (!req_fs) {\n\t\t\t\tfs_error();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfs_min_size += blob.size;\n\t\t\treq_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {\n\t\t\t\tfs.root.getDirectory(\"saved\", create_if_not_found, abortable(function(dir) {\n\t\t\t\t\tvar save = function() {\n\t\t\t\t\t\tdir.getFile(name, create_if_not_found, abortable(function(file) {\n\t\t\t\t\t\t\tfile.createWriter(abortable(function(writer) {\n\t\t\t\t\t\t\t\twriter.onwriteend = function(event) {\n\t\t\t\t\t\t\t\t\ttarget_view.location.href = file.toURL();\n\t\t\t\t\t\t\t\t\tdeletion_queue.push(file);\n\t\t\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\t\t\t\t\tdispatch(filesaver, \"writeend\", event);\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\twriter.onerror = function() {\n\t\t\t\t\t\t\t\t\tvar error = writer.error;\n\t\t\t\t\t\t\t\t\tif (error.code !== error.ABORT_ERR) {\n\t\t\t\t\t\t\t\t\t\tfs_error();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\"writestart progress write abort\".split(\" \").forEach(function(event) {\n\t\t\t\t\t\t\t\t\twriter[\"on\" + event] = filesaver[\"on\" + event];\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\twriter.write(blob);\n\t\t\t\t\t\t\t\tfilesaver.abort = function() {\n\t\t\t\t\t\t\t\t\twriter.abort();\n\t\t\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tfilesaver.readyState = filesaver.WRITING;\n\t\t\t\t\t\t\t}), fs_error);\n\t\t\t\t\t\t}), fs_error);\n\t\t\t\t\t};\n\t\t\t\t\tdir.getFile(name, {create: false}, abortable(function(file) {\n\t\t\t\t\t\t// delete file if it already exists\n\t\t\t\t\t\tfile.remove();\n\t\t\t\t\t\tsave();\n\t\t\t\t\t}), abortable(function(ex) {\n\t\t\t\t\t\tif (ex.code === ex.NOT_FOUND_ERR) {\n\t\t\t\t\t\t\tsave();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfs_error();\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}), fs_error);\n\t\t\t}), fs_error);\n\t\t}\n\t\t, FS_proto = FileSaver.prototype\n\t\t, saveAs = function(blob, name) {\n\t\t\treturn new FileSaver(blob, name);\n\t\t}\n\t;\n\tFS_proto.abort = function() {\n\t\tvar filesaver = this;\n\t\tfilesaver.readyState = filesaver.DONE;\n\t\tdispatch(filesaver, \"abort\");\n\t};\n\tFS_proto.readyState = FS_proto.INIT = 0;\n\tFS_proto.WRITING = 1;\n\tFS_proto.DONE = 2;\n\n\tFS_proto.error =\n\tFS_proto.onwritestart =\n\tFS_proto.onprogress =\n\tFS_proto.onwrite =\n\tFS_proto.onabort =\n\tFS_proto.onerror =\n\tFS_proto.onwriteend =\n\t\tnull;\n\n\tview.addEventListener(\"unload\", process_deletion_queue, false);\n\treturn saveAs;\n}(self));","Template.__define__(\"_cfsQueueProgressBar\",Package.handlebars.Handlebars.json_ast_to_func([\"<progress value=\\\"\",[\"{\",[[0,\"cfsQueueProgress\"],[0,\"collection\"],{\"fileId\":[0,\"fileId\"]}]],\"\\\" max=\\\"100\\\"\",[\"!\",[[0,\"attributes\"]]],\">\",[\"{\",[[0,\"cfsQueueProgress\"],[0,\"collection\"],{\"fileId\":[0,\"fileId\"]}]],\"%</progress>\"]));\nTemplate.__define__(\"_cfsDownloadButton\",Package.handlebars.Handlebars.json_ast_to_func([\"<button type=\\\"button\\\"\",[\"!\",[[0,\"attributes\"]]],\">\",[\"{\",[[0,\"content\"]]],\"</button>\"]));\nTemplate.__define__(\"_cfsFileInput\",Package.handlebars.Handlebars.json_ast_to_func([\"<button type=\\\"button\\\"\",[\"!\",[[0,\"attributes\"]]],\">\",[\"{\",[[0,\"content\"]]],\"</button>\\n    <input type=\\\"file\\\"\",[\"!\",[[0,\"attributes\"]]],\" />\"]));\n","/* CollectionFS.js\n * A gridFS kind implementation.\n * 2013-01-03\n *\n * By Morten N.O. Henriksen, http://gi2.dk\n *\n */\n\n// Transform api onto file objects\n_fileObject = function(doc, collection) {\n  var self = this;\n  self.collection = collection;\n  _.extend(self, doc);\n};\n\n// @export CollectionFS\nCollectionFS = function(name, options) {\n\t\"use strict\";\n\tvar self = this;\n\tself._name = name;\n\tself._filter = null;\n  // Map transformation client api\n\tself.files = new Meteor.Collection(self._name+'.files', {\n    transform: function(doc) {\n      return new _fileObject(doc, self);\n    }\n  });\n\t//TODO: Add change listener?\n\t//self.chunks = new Meteor.Collection(self._name+'.chunks');\n\tself.queue = new _queueCollectionFS(name);\n\tself._options = { autopublish: true };\n\t_.extend(self._options, options);\n\n    //events\n\tself._events = {\n    'ready': function() {},\n    'invalid': function() {}, // function(CFSErrorType, fileRecord)\n    'progress': function() {}, // function(percentageInteger)\n    'start': function() {},\n    'stop': function() {},\n    'resume': function() {}\n  };\n\n\t//Auto subscribe\n\tif (self._options.autopublish){\n    Meteor.subscribe(self._name+'.files');\n  }\n\n}; //EO collectionFS\n\n_queueCollectionFS = function(name) {\n  \"use strict\";\n\tvar self = this;\n\tself._name = name;\n\tself.fileDeps  = new Deps.Dependency();\n  // TODO: Deps could be finetuned pr. single files?\n\tself.connection = Meteor.connect(Meteor.default_connection._stream.rawUrl);\n\tself.spawns = 1;  //0 = we dont spawn into \"threads\",\n                    // 1..n = we spawn multiple \"threads\"\n\tself.paused = false;\n};\n","\"use strict\";\n\n_.extend(CollectionFS.prototype, {\n\tstoreFile: function(file, options) {\n\t\tvar self = this;\n\t\tvar fileId = null;\n\t\tvar record = self.queue.makeGridFSFileRecord(file, options);\n    if (!self.fileIsAllowed(record)) {\n      return null;\n    }\n\t\tfileId = self.files.insert(record);\n\t\tif (!fileId) {\n      return null;\n    }\n\t\t//Put file in upload queue\n\t\tself.queue.addFile(fileId, file);\n\t\treturn fileId;\n\t}, //EO storeFile\n  storeFiles: function(files, metadata, callback) {\n    var self = this, fileId, fileIds = [], file, tempMd;\n    if (files && files.length) {\n      for (var i = 0, ln = files.length; i < ln; i++) {\n        file = files[i];\n        if (metadata !== undefined && typeof metadata === 'function') {\n          tempMd = metadata(file);\n        } else {\n          tempMd = metadata;\n        }\n        fileId = self.storeFile(file, tempMd);\n        if (fileId) {\n          fileIds.push(fileId);\n        }\n        if (callback !== undefined && typeof callback === 'function') {\n          callback(file, fileId);\n        }\n      }\n    }\n    return fileIds;\n  }, //EO storeFiles\n\t//callback(fileItem)\n\tretrieveBlob: function(fileId, callback) {\n\t\t//console.log('retrieveBlob');\n\t\tvar self = this;\n\t\tvar fileItem = self.queue._getItem(fileId);\n\t\t//if file blob in queue, then use the file instead of downloading...\n\t\tif (fileItem &&(fileItem.file||fileItem.blob)) {\n\t\t\t//if file if blob\n\t\t\tcallback(fileItem);\n\t\t} else {\n\t\t\tvar fileRecord = self.files.findOne({ _id: fileId});\n\t\t\t//download into queue file blob\n\t\t\tself.queue.getFile(fileRecord, callback);\n\t\t}\n\t\t//return blob\n\t}, //EO retrieveBlob\n\tretrieveFile: function(fileId, callback) {\n\t\t//check if found locally - then use directly\n\t\t//fetch from server, via methods call - dont want the chunks collection\n\t}, //EO retriveFile\n  acceptDropsOn: function(templateName, selector, metadata, callback) {\n    var self = this, events = {};\n    // Prevent default drag and drop\n    function noopHandler(evt) {\n      evt.stopPropagation();\n      evt.preventDefault();\n    }\n\n    // Handle file dropped\n    function dropped(evt) {\n      noopHandler(evt);\n      self.storeFiles(evt.dataTransfer.files, metadata, callback);\n    }\n\n    events['dragenter ' + selector] = noopHandler;\n    events['dragexit ' + selector] = noopHandler;\n    events['dragover ' + selector] = noopHandler;\n    events['dragend ' + selector] = noopHandler;\n    events['drop ' + selector] = dropped;\n\n    Template[templateName].events(events);\n  }\n}); //EO extend collection\n\n\n_.extend(_queueCollectionFS.prototype, {\n\n\t//////////////////////////////////////////////////////////////////////////////\n\t////////////////////////////// Getters ///////////////////////////////////////\n\t//////////////////////////////////////////////////////////////////////////////\n\n\tgetItem: function(fileId) {\n\t\tvar self = this;\n\t\tself.fileDeps.depend();\n\t\treturn self._getItem(fileId);\n\t}, //EO getItem\n\n\t//_getItem is private function, not reactive\n\t_getItem: function(fileId) {\n\t\tvar self = this;\n\t\treturn self.queue[fileId];\n\t}, //EO _getItem\n\n  //_getProgress is private function, not reactive\n  _getProgress: function(fileId, onlyBuffer) {\n    var self = this;\n    var fileItem = self._getItem(fileId);\n    if (!fileItem) {\n      return false;\n    }\n\n    if (fileItem.complete) {\n      return 100;\n    }\n\n    var pointerChunk = (onlyBuffer) ?\n            fileItem.currentChunk : fileItem.currentChunkServer; //TODO:\n\n    if (fileItem) {\n      return Math.round(pointerChunk / fileItem.countChunks * 100);\n    } else {\n      return 0;\n    }\n  }, //EO _getProgress\n\n\tprogress: function(fileId, onlyBuffer) {\n\t\tvar self = this;\n    self.fileDeps.depend();\n    return self._getProgress(fileId, onlyBuffer);\n\t}, //EO progress\n\n\tisComplete: function(fileId) {\n    var self = this;\n    self.fileDeps.depend();\n    var fileItem = self._getItem(fileId);\n    if (!fileItem) {\n      return true;\n    }\n    return fileItem.complete;\n\t}, //EO isComplete\n\n  isUploading: function(fileId) {\n    var self = this;\n    self.fileDeps.depend();\n    var fileItem = self._getItem(fileId);\n    if (!fileItem || fileItem.download) {\n      return false;\n    }\n    var progress = self._getProgress(fileId);\n    return (progress && progress > 0 && progress < 100);\n  }, //EO isUploading\n\n\tisDownloading: function(fileId) {\n\t\tvar self = this;\n    self.fileDeps.depend();\n\t\tvar fileItem = self._getItem(fileId);\n\t\tif (!fileItem || !fileItem.download) {\n      return false;\n    }\n    var progress = self._getProgress(fileId);\n    return (progress && progress > 0 && progress < 100);\n\t}, //EO isDownloading\n\n\tisDownloaded: function(fileId) {\n\t\tvar self = this;\n\t\tself.fileDeps.depend();\n\t\tvar fileItem = self._getItem(fileId);\n\t\tif (fileItem.file) {\n      return true;\n    }\n\t\tif (fileItem.download) {\n\t\t\treturn (fileItem.currentChunk === fileItem.countChunks-1);\n\t\t}\n\t\treturn false;\n\t}, //EO isDownloaded\n\n\tisPaused: function() {\n\t\tvar self = this;\n\t\tself.fileDeps.depend();\n\t\treturn self.paused;\n\t}, //EO isPaused\n\n\n\t//////////////////////////////////////////////////////////////////////////////\n\t/////////////////////////////// Queue ////////////////////////////////////////\n\t//////////////////////////////////////////////////////////////////////////////\n\t//Bind to hot push code to resume after server reboot\n\tresume: function() {\n\t\tvar self = this;\n\t\tself.paused = false;\n\t\tself.fileDeps.changed();\n\t\t//console.log('paused:'+self.paused);\n\t\tfor (var fileId in self.queue) {\n\t\t\tvar fileItem = self._getItem(fileId);\n\t\t\tif (fileItem.download) {\n\t\t\t\t//Spawn loaders\n\t\t\t\tif (!self.spawns){\n          self.downloadChunk(fileId);\n        } else {\n\t\t\t\t\tfor (var i = 0; i < self.spawns; i++) {\n            setTimeout(function() { self.downloadChunk(fileId); });\n          }\n        }\n\t\t\t} else {\n\t\t\t\t//Spawn loaders\n\t\t\t\tif (!self.spawns) {\n\t\t\t\t\tself.getDataChunk(fileId);\n\t\t\t\t} else {\n          for (var i = 0; i < self.spawns; i++) {\n            setTimeout(function() { self.getDataChunk(fileId); });\n          }\n        }\n\t\t\t}\n\t\t}\n\t}, //EO resume\n\n\tpause: function() {\n\t\tthis.paused = true;\n\t\tthis.fileDeps.changed();\n\t},\n\n\tresumeFile: function(fileRecord, file) {\n\t\tvar self = this;\n\t\tvar testFileRecord = self.makeGridFSFileRecord(file);\n\t\tif (self.compareFile(fileRecord, testFileRecord)) {\n\t\t\tself.addFile(fileRecord._id, file, fileRecord.currentChunk);\n\t\t\treturn true;\n\t\t}\n\t\t//console.log('resumeFile - files dont match');\n\t\treturn false; //Didnt compare - cant resumeFile\n\t}, //EO function\n\t//////////////////////////////////////////////////////////////////////////////\n\t/////////////////////////////// DOWNLOAD  ////////////////////////////////////\n\t//////////////////////////////////////////////////////////////////////////////\n\taddDataChunk: function(fileId, chunckNumber, data) {\n\t\tvar self = this;\n\t\tvar fileItem = self._getItem(fileId);\n\n    var carry = [];\n    for(var i = 0; i < data.length; i++) {\n      carry.push(data.charCodeAt(i));\n    }\n\n\t\tself.queue[fileId].queueChunks[chunckNumber] = new Uint8Array(carry);\n    //chunkBlob; TODO: use EJSON.binary()\n\t},\n\n\tunionChunkBlobs: function(fileId) {\n\t\tvar self = this;\n\t\tvar fileItem = self._getItem(fileId);\n\n\t\tif (fileItem.queueChunks.length === fileItem.countChunks) {\n      //Last worker make chunks into blob\n\t\t\tself.queue[fileId].blob = new Blob(fileItem.queueChunks,\n              { type: fileItem.contentType });\n\t\t\tvar myCallback = fileItem.callback;\n\t\t\tif (fileItem.callback) {\n\t\t\t\tfileItem.callback = null; //Only do this once\n\t\t\t\tmyCallback(self._getItem(fileId));\n\t\t\t}\n\t\t\t//Now completed, trigger update\n\t\t\tself.fileDeps.changed();\n\t\t}\n\t},\n\n\tdownloadChunk: function(fileId, optChunkNumber) {\n\t\tvar self = this;\n\t\tvar fileItem = self._getItem(fileId);\n\t\tvar myChunkNumber = optChunkNumber || self.nextChunk(fileId);\n\t\tif (myChunkNumber === false) {\n\t\t\treturn false;\n    }\n\n\t\tself.lastCountDownload++;\n\t\tif (self.lastTimeDownload) {\n\t\t\tif (self.lastCountDownload === 10) {\n\t\t\t\tself.lastCountDownload = 0;\n\t\t\t\tvar bitPrSecDownload = (8 * self.chunkSize * 10) /\n                ((Date.now()-self.lastTimeDownload ) / 100);\n        var oldBitPrSecDownload = (Session.get('bitPrSecDownload'))?\n                Session.get('bitPrSecDownload'):bitPrSecDownload;\n\t\t\t\tSession.set('bitPrSecDownload',\n                Math.round( (oldBitPrSecDownload*9 + bitPrSecDownload)/10) );\n\t\t\t\tself.lastTimeDownload = Date.now();\n\t\t\t}\n\t\t} else {\n\t\t\tself.lastTimeDownload = Date.now();\n\t\t}\n\n\t\tself.connection.apply('loadChunck'+fileItem.collectionName, [\n\t\t\tfileId = fileId,\n\t\t\tchunkNumber = myChunkNumber,\n\t\t\tcountChunks = fileItem.countChunks\n\t\t],[\n\t\t\twait = true\n\t\t],\n\t\t\tfunction(error, result) {\n\t\t\t\t//Callback\n\t\t\t\tif (result.chunkId) {\n\n\t\t\t\t\tself.queue[fileId].currentChunkServer = result.currentChunk+1;\n\t\t\t\t\tself.addDataChunk(fileId, myChunkNumber, result.data);\n\t\t\t\t\tvar next = self.nextChunk(fileId);\n\t\t\t\t\t//console.log('Got: '+myChunkNumber+' next:'+next);\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\tself.downloadChunk(fileId, next);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (self.queue[fileId].queueChunks.length ===\n                    self.queue[fileId].countChunks) {\n\t\t\t\t\t\t\tself.unionChunkBlobs(fileId);\n\t\t\t\t\t\t} /* else {\n\t\t\t\t\t\t\t//console.log('Waiting for last arrivals');\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\t//update and notify listenters\n\n\t\t\t\t\t\t/*if (self.queue[fileId].currentChunk % 1 == 0) {\n\t\t\t\t\t\t\tself.fileDeps.changed();\n\t\t\t\t\t\t}*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}//EO func\n\t\t);//EO Meteor.apply\n\t}, //EO\n\n\t// getFile callback(fileItem)\n\tgetFile: function(fileRecord, callback, currentChunk) {\n\t\tvar self = this;\n\t\tself.queue[fileRecord._id] = {\n\t\t\t_id: fileRecord._id,\n\t\t\tdownload: true,\n\t\t\tcomplete: false,\n\t\t\tfile: null,\n\t\t\tblob: null,\n\t\t\tqueueChunks: [],\n\t\t\tcollectionName:self._name,\n      filename: fileRecord.filename,\n\t\t\tconnection:self.connection,\n\t\t\tcontentType: fileRecord.contentType,\n\t\t\tcurrentChunkServer: (currentChunk)?currentChunk:0,\n\t\t\tcurrentChunk: (currentChunk)?currentChunk:0,\n      //current loaded chunk of countChunks-1\n      countChunks: fileRecord.countChunks,\n\t\t\tcallback: callback,\n//\t\t\t\tlen: fileRecord['len']\n\t\t\tlength: ''+fileRecord['length']  //When fix in meteor dont add ''+\n\n\t\t};\n\n\t\t//Added download request to the queue\n\t\tself.fileDeps.changed();\n\n\t\t//Spawn loaders\n\t\tif (!self.spawns) {\n\t\t\tself.downloadChunk(fileRecord._id);\n\t\t} else {\n\t\t\tfor (var i = 0; i < self.spawns; i++) {\n        setTimeout(function() { self.downloadChunk(fileRecord._id); });\n      }\n    }\n\t}, //EO\n\t//////////////////////////////////////////////////////////////////////////////\n\t//////////////////////////////// UPLOAD //////////////////////////////////////\n\t//////////////////////////////////////////////////////////////////////////////\n\n\taddFile: function(fileId, file, currentChunk) {\n\t\tvar self = this;\n\t\tvar countChunks = Math.ceil(file.size / self.chunkSize);\n\t\tself.queue[fileId] = {\n\t\t\t_id: fileId,\n\t\t\tdownload: false,\n\t\t\tcomplete: false,\n\t\t\tfile: file,\n      filename: file.name,\n\t\t\tcollectionName:self._name,\n\t\t\tconnection:self.connection,\n\t\t\tcurrentChunkServer: (currentChunk)?currentChunk:0,\n\t\t\tcurrentChunk: (currentChunk)?currentChunk:0,\n      //current loaded chunk of countChunks-1\n\t\t\tcountChunks: countChunks\n\t\t\t//filereader: new FileReader(),\n\t\t};\n\t\t//Added upload request to the queue\n\t\tself.fileDeps.changed();\n\n\t\t//Spawn loaders\n\t\tif (!self.spawns) {\n\t\t\tself.getDataChunk(fileId, 0);\n\t\t} else {\n\t\t\tfor (var i = 0; i < self.spawns; i++) {\n\t\t\t\tsetTimeout(function() { self.getDataChunk(fileId); });\n      }\n    }\n\t}, //EO addFile\n\n\tgetDataChunk: function(fileId, optChunkNumber) {\n\t\tvar self = this;\n\t\tvar myChunkNumber = optChunkNumber || self.nextChunk(fileId);\n\t\tif (myChunkNumber === false) {\n\t\t\treturn false;\n    }\n\t\tvar f = self.queue[fileId].file;\n\t\tvar myreader = new FileReader();\n\t\tvar start = myChunkNumber * self.chunkSize;\n\t\t//make sure not to exeed boundaries\n\t\tvar stop = Math.min(start + self.chunkSize, f.size);\n\t\tvar slice = f.slice||f.webkitSlice||f.mozSlice;\n\t\tvar blob = slice.call(f, start, stop, f.contentType);\n\n\t\tmyreader.onloadend = function(evt) {\n\t\t\tif (evt.target.readyState === FileReader.DONE) {\n\t\t\t\tself.uploadChunk(fileId, myChunkNumber, evt.target.result);\n\t\t\t}\n\t\t};\n\n\t\tif (blob) {\n\t\t\tmyreader.readAsBinaryString(blob);\n\t\t} else {\n\t\t\tthrow new Error('Slice function not supported, fileId:'+fileId);\n\t\t}\n\t}, //EO get data chunk\n\n\tuploadChunk: function(fileId, chunkNumber, data) {\n\t\tvar self = this;\n\t\tvar fileItem = self._getItem(fileId);\n\n\t\tself.lastCountUpload++;\n\t\tif (self.lastTimeUpload) {\n\t\t\tif (self.lastCountUpload === 10) {\n\t\t\t\tself.lastCountUpload = 0;\n\t\t\t\tvar bitPrSecUpload = (8 * self.chunkSize * 10) /\n                ((Date.now()-self.lastTimeUpload ) / 100);\n\t\t\t\tvar oldBitPrSecUpload = (Session.get('bitPrSecUpload'))?\n                Session.get('bitPrSecUpload'):bitPrSecUpload;\n\t\t\t\tSession.set('bitPrSecUpload',\n                Math.round( (oldBitPrSecUpload*9 + bitPrSecUpload)/10) );\n\t\t\t\tself.lastTimeUpload = Date.now();\n\t\t\t}\n\t\t} else {\n\t\t\tself.lastTimeUpload = Date.now();\n\t\t}\n\n\t\tself.connection.apply('saveChunck'+fileItem.collectionName, [\n\t\t\tfileId = fileId,\n\t\t\tcurrentChunk = chunkNumber,\n\t\t\tcountChunks = fileItem.countChunks,\n\t\t\tdata = data\n\t\t],[\n\t\t\twait = true\n\t\t], function(error, result) {\n\t\t\t\t//Callback\n\t\t\t\tif (error) {\n          console.log(error);\n        }\n\n\t\t\t\tif (result.chunkId) {\n\t\t\t\t\tself.queue[fileId].currentChunkServer = result.currentChunk;\n\n\t\t\t\t\t//TODO: Really, should the next function rule? or the\n          // result.currentChunk?\n\t\t\t\t\t//The result could be async? multiple users\n\t\t\t\t\t//Use in >saveChunk< function:\n\t\t\t\t\t//\tupdating files $inc: { currentChunk: 0 } until == countChunks\n\t\t\t\t\t//\tif not missing any chunks then complete else request client to\n          // upload by returning missing chunk number?\n\t\t\t\t\t//\n\t\t\t\t\t// var next = result.currentChunck;  //Chunck to download.. if not the\n          // save func gotta test fs.chunks index\n\n\t\t\t\t\tvar next = self.nextChunk(result.fileId); //or let server decide\n\t\t\t\t\t//!result.complete &&\n\t\t\t\t\tif (!result.complete) {\n\t\t\t\t\t\tself.getDataChunk(result.fileId, next);\n\t\t\t\t\t} /*else {\n\t\t\t\t\t\t//Client or server check chunks..\n\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\n\t\t);\n\t}, //uploadNextChunk\n\t//nextChunk returns next chunkNumber\n\tnextChunk: function(fileId) {\n\t\tvar self = this;\n\t\tif (self.isPaused()){\n      return false;\n    }\n    //self.queue[fileId].countChunks = 1; //Uncomment for debugging\n\t\tself.queue[fileId].complete =\n          (self.queue[fileId].currentChunk === self.queue[fileId].countChunks);\n\t\t//  Queue progressed\n    //\tif (self.queue[fileId].currentChunk % 1 == 0 ||\n    //          self.queue[fileId].complete)\n    self.fileDeps.changed();\n\t\tif (self.queue[fileId].complete) {\n\t\t\t//done\n\t\t\t//XXX: Spawn complete event?\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif (!self.queue[fileId].complete) { self.queue[fileId].currentChunk++; }\n\t\t\t//XXX: Spawn progress event?\n\t\t\treturn self.queue[fileId].currentChunk-1;\n\t\t}\n\t} //EO nextChunk\n\n\n}); //EO\n","\"use strict\";\n\n\n/*\n  CLIENT API\n\n  The clientFileObject is equal to the fileRecord + client-side api\n  This pattern will allow easier manipulation of files since we now pass\n  file objects with methods attatched.\n  In many cases we are only passed content objects with no reference to the\n  collection attached - This way we actually know were the data belongs and\n  makes operations much easier.\n\n  Eg.\n\n  Template.test.events({\n    'click .file': function(event, temp) {\n      this._id...\n      this.toDataUrl()\n      this.toBlob()\n      this.remove()\n      this.getExtension()\n      this.getUrl()\n    }\n  });\n\n*/\n_.extend(_fileObject.prototype, {\n  // Expect self to have the properties of fileRecord\n  // Added is self.collection for access to the collection the file belongs\n\n  // TODO: Add client file object api\n  toDataUrl: function(callback) {\n    if (typeof callback !== 'function') {\n      throw new Error(\"toDataUrl requires function as callback\");\n    }\n\n    var data;\n\n    // TODO: Load file into data as 'base64 -> url'\n\n    callback(data);\n  },\n  toBlob: function(callback) {\n    if (typeof callback !== 'function') {\n      throw new Error(\"toBlob requires function as callback\");\n    }\n\n    var data;\n\n    // TODO: Load file into data as 'blob'\n\n    callback(data);\n  }\n});","\"use strict\";\n\nif (typeof Handlebars !== 'undefined') {\n  //Usage:\n  //{{cfsFile \"Collection\" fileId}}\n  Handlebars.registerHelper('cfsFile', function(collection, fileId) {\n    return window[collection].findOne(fileId);\n  });\n\n  //Usage:\n  //{{cfsFiles \"Collection\"}}\n  Handlebars.registerHelper('cfsFiles', function(collection) {\n    return window[collection].find();\n  });\n\n  //Usage:\n  //{{#if cfsHasFiles \"Collection\"}}\n  Handlebars.registerHelper('cfsHasFiles', function(collection) {\n    return window[collection].find().count() > 0;\n  });\n\n  //Usage:\n  //(1) {{cfsIsUploading \"Collection\"}} (with file as current context)\n  //(2) {{cfsIsUploading \"Collection\" file=file}}\n  //(3) {{cfsIsUploading \"Collection\" fileId=fileId}}\n  Handlebars.registerHelper('cfsIsUploading', function(collection, opts) {\n    var fileId, hash, CFS;\n    hash = opts && opts.hash ? opts.hash : {};\n    if (hash.file) {\n      fileId = hash.file._id;\n    } else {\n      fileId = hash.fileId || this._id;\n    }\n    if (!fileId) {\n      return false;\n    }\n    CFS = window[collection];\n    if (!CFS || !CFS.queue) {\n      return false;\n    }\n    return CFS.queue.isUploading(fileId);\n  });\n\n  //Usage:\n  //(1) {{cfsIsDownloading \"Collection\"}} (with file as current context)\n  //(2) {{cfsIsDownloading \"Collection\" file=file}}\n  //(3) {{cfsIsDownloading \"Collection\" fileId=fileId}}\n  Handlebars.registerHelper('cfsIsDownloading', function(collection, opts) {\n    var fileId, hash, CFS;\n    hash = opts && opts.hash ? opts.hash : {};\n    if (hash.file) {\n      fileId = hash.file._id;\n    } else {\n      fileId = hash.fileId || this._id;\n    }\n    if (!fileId) {\n      return false;\n    }\n    CFS = window[collection];\n    if (!CFS || !CFS.queue) {\n      return false;\n    }\n    return CFS.queue.isDownloading(fileId);\n  });\n\n  //Usage:\n  //(1) {{cfsIsDownloaded \"Collection\"}} (with file as current context)\n  //(2) {{cfsIsDownloaded \"Collection\" file=file}}\n  //(3) {{cfsIsDownloaded \"Collection\" fileId=fileId}}\n  Handlebars.registerHelper('cfsIsDownloaded', function(collection, opts) {\n    var fileId, hash, CFS;\n    hash = opts && opts.hash ? opts.hash : {};\n    if (hash.file) {\n      fileId = hash.file._id;\n    } else {\n      fileId = hash.fileId || this._id;\n    }\n    if (!fileId) {\n      return false;\n    }\n    CFS = window[collection];\n    if (!CFS || !CFS.queue) {\n      return false;\n    }\n    return CFS.queue.isDownloaded(fileId);\n  });\n\n  //Usage:\n  //(1) {{cfsIsComplete \"Collection\"}} (with file as current context)\n  //(2) {{cfsIsComplete \"Collection\" file=file}}\n  //(3) {{cfsIsComplete \"Collection\" fileId=fileId}}\n  Handlebars.registerHelper('cfsIsComplete', function(collection, opts) {\n    var fileId, hash, CFS;\n    hash = opts && opts.hash ? opts.hash : {};\n    if (hash.file) {\n      fileId = hash.file._id;\n    } else {\n      fileId = hash.fileId || this._id;\n    }\n    if (!fileId) {\n      return false;\n    }\n    CFS = window[collection];\n    if (!CFS || !CFS.queue) {\n      return false;\n    }\n    return CFS.queue.isComplete(fileId);\n  });\n\n  //Usage:\n  //(1) {{cfsQueueProgress \"Collection\"}} (with file as current context)\n  //(2) {{cfsQueueProgress \"Collection\" file=file}}\n  //(3) {{cfsQueueProgress \"Collection\" fileId=fileId}}\n  Handlebars.registerHelper('cfsQueueProgress', function(collection, opts) {\n    var fileId, hash, CFS;\n    hash = opts && opts.hash ? opts.hash : {};\n    if (hash.file) {\n      fileId = hash.file._id;\n    } else {\n      fileId = hash.fileId || this._id;\n    }\n    if (!fileId) {\n      return false;\n    }\n    CFS = window[collection];\n    if (!CFS || !CFS.queue) {\n      return false;\n    }\n    return CFS.queue.progress(fileId);\n  });\n\n  //Usage:\n  //(1) {{cfsQueueProgressBar \"Collection\"}} (with file as current context)\n  //(2) {{cfsQueueProgressBar \"Collection\" file=file}}\n  //(3) {{cfsQueueProgressBar \"Collection\" fileId=fileId}}\n  //Supported Options: id, class\n  Handlebars.registerHelper('cfsQueueProgressBar', function(collection, opts) {\n    var fileId, hash;\n    hash = opts && opts.hash ? opts.hash : {};\n    if (hash.file) {\n      fileId = hash.file._id;\n    } else {\n      fileId = hash.fileId || this._id;\n    }\n    if (!fileId) {\n      return false;\n    }\n    return new Handlebars.SafeString(Template._cfsQueueProgressBar({\n      collection: collection,\n      fileId: fileId,\n      attributes: (hash.id ? ' id=\"' + hash.id + '\"' : '') + (hash.class ?\n              ' class=\"' + hash.class + '\"' : '')\n    }));\n  });\n\n  //Usage:\n  //{{cfsIsPaused \"Collection\"}}\n  Handlebars.registerHelper('cfsIsPaused', function(collection) {\n    var CFS = window[collection];\n    if (!CFS || !CFS.queue) {\n      return false;\n    }\n    return CFS.queue.isPaused();\n  });\n\n  //Usage (Is current user the owner?):\n  //(1) {{cfsIsOwner}} (with file as current context)\n  //(2) {{cfsIsOwner file=file}}\n  //(3) {{cfsIsOwner fileId=fileId collection=\"Collection\"}}\n  //Usage (Is user with userId the owner?):\n  //(1) {{cfsIsOwner userId=userId}} (with file as current context)\n  //(2) {{cfsIsOwner file=file userId=userId}}\n  //(3) {{cfsIsOwner fileId=fileId collection=\"Collection\" userId=userId}}\n  Handlebars.registerHelper('cfsIsOwner', function(opts) {\n    var file, hash, userId;\n    hash = opts && opts.hash ? opts.hash : {};\n    userId = hash.userId || Meteor.userId();\n    if (hash.fileId && hash.collection) {\n      file = window[hash.collection].findOne(hash.fileId);\n    }\n    if (!file) {\n      file = hash.file || this;\n    }\n    if (!file) {\n      return false;\n    }\n    return (file.owner === userId);\n  });\n\n  //Usage (default format string):\n  //(1) {{cfsFormattedSize}} (with file as current context)\n  //(2) {{cfsFormattedSize file=file}}\n  //(3) {{cfsFormattedSize fileId=fileId collection=\"Collection\"}}\n  //Usage (any format string supported by numeral.format):\n  //(1) {{cfsFormattedSize formatString=formatString}}\n  //        (with file as current context)\n  //(2) {{cfsFormattedSize file=file formatString=formatString}}\n  //(3) {{cfsFormattedSize fileId=fileId collection=\"Collection\"\n  //        formatString=formatString}}\n  Handlebars.registerHelper('cfsFormattedSize', function(opts) {\n    var file, hash, formatString;\n    hash = opts && opts.hash ? opts.hash : {};\n    if (hash.fileId && hash.collection) {\n      file = window[hash.collection].findOne(hash.fileId);\n    }\n    if (!file) {\n      file = hash.file || this;\n    }\n    if (!file) {\n      return \"Unknown\";\n    }\n    formatString = hash.formatString || '0.00 b';\n    return numeral(file.length).format(formatString);\n  });\n\n  //Usage:\n  //(1) {{cfsFileHandlers}} (with file as current context)\n  //(2) {{cfsFileHandlers file=file}}\n  //(3) {{cfsFileHandlers fileId=fileId collection=\"Collection\"}}\n  Handlebars.registerHelper('cfsFileHandlers', function(opts) {\n    var file, hash, fh, fId, fileHandlers = [];\n    hash = opts && opts.hash ? opts.hash : {};\n    if (hash.fileId && hash.collection) {\n      file = window[hash.collection].findOne(hash.fileId);\n    }\n    if (!file) {\n      file = hash.file || this;\n    }\n    if (!file || !file.fileHandler) {\n      return fileHandlers;\n    }\n    // TODO: more safe iteration\n    for (fId in file.fileHandler) {\n      fileHandlers.push(fId);\n    }\n    return fileHandlers;\n  });\n\n  //Usage:\n  //(1) {{cfsFileUrl \"defaultHandler\"}} (with file as current context)\n  //(2) {{cfsFileUrl \"defaultHandler\" file=file}}\n  //(3) {{cfsFileUrl \"defaultHandler\" fileId=fileId collection=\"Collection\"}}\n  Handlebars.registerHelper('cfsFileUrl', function(fileHandler, opts) {\n    var file, hash, fh;\n    hash = opts && opts.hash ? opts.hash : {};\n    if (hash.fileId && hash.collection) {\n      file = window[hash.collection].findOne(hash.fileId);\n    }\n    if (!file) {\n      file = hash.file || this;\n    }\n    if (!file || !file.fileHandler) {\n      return \"\";\n    }\n    fh = file.fileHandler[fileHandler];\n    if (!fh) {\n      return \"\";\n    }\n    return fh.url;\n  });\n\n  //Usage:\n  //(1) {{cfsDownloadButton \"Collection\"}} (with file as current context)\n  //(2) {{cfsDownloadButton \"Collection\" file=file}}\n  //(3) {{cfsDownloadButton \"Collection\" fileId=fileId}}\n  //Supported Options: id, class, content\n  Handlebars.registerHelper('cfsDownloadButton', function(collection, opts) {\n    var fileId, hash, atts;\n    hash = opts && opts.hash ? opts.hash : {};\n    if (hash.file) {\n      fileId = hash.file._id;\n    } else {\n      fileId = hash.fileId || this._id;\n    }\n    if (!fileId) {\n      return false;\n    }\n    hash.class = hash.class ? hash.class + ' cfsDownloadButton' :\n            'cfsDownloadButton';\n    atts = (hash.id ? ' id=\"' + hash.id + '\"' : '') + (hash.class ?\n            ' class=\"' + hash.class + '\"' : '');\n    hash.content = hash.content || \"Download\";\n    return new Handlebars.SafeString(Template._cfsDownloadButton({\n      collection: collection,\n      fileId: fileId,\n      content: hash.content,\n      attributes: atts\n    }));\n  });\n\n  Template._cfsDownloadButton.events({\n    'click .cfsDownloadButton': function(event, template) {\n      var fileId = template.data.fileId,\n              collection = template.data.collection, CFS;\n      if (!fileId || !collection) {\n        return false;\n      }\n      CFS = window[collection];\n      if (!CFS || !CFS.queue) {\n        return false;\n      }\n      CFS.retrieveBlob(fileId, function(fileItem) {\n        if (fileItem.blob) {\n          window.saveAs(fileItem.blob, fileItem.filename);\n        } else {\n          window.saveAs(fileItem.file, fileItem.filename);\n        }\n      });\n    }\n  });\n\n  //TODO make this work and test thoroughly\n  Template._cfsFileInput.events({\n    'change .cfsFileInput': function(event, template) {\n      var elem = event.target,\n        files = elem.files,\n        storeIdsFor = template.data.storeIdsFor,\n        path = template.data.storeIdsIn,\n        collection = template.data.collection,\n        multiple = template.data.multiple,\n        set = {},\n        collectionName, indexOfFirstDot;\n      if (files) {\n        var ids = window[collection].storeFiles(files);\n        if (path && path.length) {\n          indexOfFirstDot = path.indexOf('.');\n          if (indexOfFirstDot === -1) {\n            return;\n          }\n          collectionName = path.slice(0, indexOfFirstDot);\n          path = path.slice(indexOfFirstDot + 1);\n\n          if (multiple) {\n            setObjByString(set, path, ids);\n          } else {\n            if (ids.length) {\n              setObjByString(set, path, ids[0]);\n            } else {\n              setObjByString(set, path, null);\n            }\n          }\n          window[collectionName].update(storeIdsFor, {$set: set});\n        }\n      }\n    }\n  });\n\n  //Usage: (TODO)\n  Handlebars.registerHelper('cfsFileInput', function(collection, options) {\n    var html, hash = options.hash, styles, atts;\n    switch (hash.type) {\n      case \"file\":\n        hash.class = hash.class ? hash.class + ' cfsFileInput' : 'cfsFileInput';\n        atts = (hash.id ? ' id=\"' + hash.id + '\"' : '') + (hash.class ?\n                ' class=\"' + hash.class + '\"' : '') +\n                (hash.name ? ' name=\"' + hash.name + '\"' : '') +\n                (hash.multiple ? ' multiple' : '');\n        html = Template._cfsFileInput({\n          collection: collection,\n          multiple: hash.multiple,\n          storeIdsIn: hash.storeIdsIn,\n          storeIdsFor: hash.storeIdsFor,\n          attributes: atts\n        });\n        break;\n      case \"image\":\n        //TODO\n        break;\n    }\n    return new Handlebars.SafeString(html);\n  });\n} else {\n  console.log(\"no handlebars\");\n}\n","\"use strict\";\n\n//utility functions\n// Todo: should be transformed on to file objects?\ngetFileExtension = function(name) {\n  var found = name.lastIndexOf('.') + 1;\n  return (found > 0 ? name.substr(found) : \"\");\n};\n\ncontentTypeInList = function(list, contentType) {\n  var listType, found = false;\n  for (var i = 0, ln = list.length; i < 10; i++) {\n    listType = list[i]; // TODO: if i > ln\n    if (listType === contentType) {\n      found = true;\n      break;\n    }\n    if (listType === \"image/*\" && contentType.indexOf(\"image/\") === 0) {\n      found = true;\n      break;\n    }\n    if (listType === \"audio/*\" && contentType.indexOf(\"audio/\") === 0) {\n      found = true;\n      break;\n    }\n    if (listType === \"video/*\" && contentType.indexOf(\"video/\") === 0) {\n      found = true;\n      break;\n    }\n  }\n  return found;\n};\n\nsetObjByString = function(obj, str, val) {\n  var keys, key;\n  //make sure str is a nonempty string\n  if (str === ''+str && str !== '') {\n    return false;\n  }\n  if (!Match.test(obj, {})) {\n    //if it's not an object, make it one\n    obj = {};\n  }\n  keys = str.split(\".\");\n  while (keys.length > 1) {\n    key = keys.shift();\n    if (obj !== Object(obj)) {\n      //if it's not an object, make it one\n      obj = {};\n    }\n    if (!(key in obj)) {\n      //if obj doesn't contain the key, add it and set it to an empty object\n      obj[key] = {};\n    }\n    obj = obj[key];\n  }\n  return obj[keys[0]] = val; // TODO: Are we checking or setting?\n};\n\n// TODO: Refractor code:\n// use check(str, String); or Match.test(str, String);\nisString = function() {\n  throw Error('isString deprecated');\n  // return Object.prototype.toString.call(str) === \"[object String]\";\n};\n/*\nNonEmptyString = Match.Where(function (x) {\n  check(x, String);\n  return x.length > 0;\n}\n*/\n\n// TODO: refractor use: !!(check(str, String) && str.length > 0)\nisNonEmptyString = function() {\n  throw Error('isNonEmptyString deprecated');\n  // return isString(str) && str.length;\n};\n\n// TODO: refractor to use: check(obj, Object)\nisObject = function() {\n  throw Error('isObject deprecated');\n  // return obj === Object(obj);\n};\n\nvar cleanOptions = function() {\n  throw Error('cleanOptions deprecated');\n  // return options;\n};\n","\"use strict\";\n\n// Make files basic functions available in CollectionFS\n_.extend(CollectionFS.prototype, {\n\tfind: function() {\n    return this.files.find.apply(this.files, arguments);\n  },\n\tfindOne: function() {\n    return this.files.findOne.apply(this.files, arguments);\n  },\n\tupdate: function() {\n    return this.files.update.apply(this.files, arguments);\n  },\n\tremove: function() {\n    return this.files.remove.apply(this.files, arguments);\n  },\n\tallow: function() {\n    return this.files.allow.apply(this.files, arguments);\n  },\n\tdeny: function() {\n    return this.files.deny.apply(this.files, arguments);\n  },\n\tfileHandlers: function(options) {\n    _.extend(this._fileHandlers, options);\n  },\n  filter: function(options) {\n    //clean up filter option values\n    if (!options.allow || !Match.test(options.allow, Object)) {\n      options.allow = {};\n    }\n    if (!options.deny || !Match.test(options.deny, Object)) {\n      options.deny = {};\n    }\n    if (!options.maxSize || !_.isNumber(options.maxSize)) {\n      options.maxSize = false;\n    }\n    if (!options.allow.extensions || !_.isArray(options.allow.extensions)) {\n      options.allow.extensions = [];\n    }\n    if (!options.allow.contentTypes || !_.isArray(options.allow.contentTypes)) {\n      options.allow.contentTypes = [];\n    }\n    if (!options.deny.extensions || !_.isArray(options.deny.extensions)) {\n      options.deny.extensions = [];\n    }\n    if (!options.deny.contentTypes || !_.isArray(options.deny.contentTypes)) {\n      options.deny.contentTypes = [];\n    }\n\n    this._filter = options;\n  },\n  fileIsAllowed: function(fileRecord) {\n    var self = this;\n    if (!self._filter) {\n      return true;\n    }\n    if (!fileRecord || !fileRecord.contentType || !fileRecord.filename) {\n      throw new Error(\"invalid fileRecord:\", fileRecord);\n    }\n    var fileSize = fileRecord.size || parseInt(fileRecord.length, 10);\n    if (!fileSize || isNaN(fileSize)) {\n      throw new Error(\"invalid fileRecord file size:\", fileRecord);\n    }\n    var filter = self._filter;\n    if (filter.maxSize && fileSize > filter.maxSize) {\n      self.dispatch('invalid', { maxFileSizeExceeded: true }, fileRecord);\n      return false;\n    }\n    var saveAllFileExtensions = (filter.allow.extensions.length === 0);\n    var saveAllContentTypes = (filter.allow.contentTypes.length === 0);\n    var ext = getFileExtension(fileRecord.filename);\n    var contentType = fileRecord.contentType;\n    if (!((saveAllFileExtensions ||\n            _.indexOf(filter.allow.extensions, ext) !== -1) &&\n            _.indexOf(filter.deny.extensions, ext) === -1)) {\n      self.dispatch('invalid', { disallowedExtension: true }, fileRecord);\n      return false;\n    }\n    if (!((saveAllContentTypes ||\n            contentTypeInList(filter.allow.contentTypes, contentType)) &&\n            !contentTypeInList(filter.deny.contentTypes, contentType))) {\n      self.dispatch('invalid', { disallowedContentType: true }, fileRecord);\n      return false;\n    }\n    return true;\n  },\n  events: function (events) {\n    var self = this;\n    _.extend(self._events, events);\n  },\n  dispatch: function (/* arguments */) {\n    var self = this, args = _.toArray(arguments);\n    var eventName = args.shift();\n    self._events[eventName].apply(self, args);\n  }\n});\n\n_.extend(_queueCollectionFS.prototype, {\n\tqueue: {},\n\tchunkSize: 256 * 1024,    //gridFS default is 256kb = 262.144bytes\n\tcompareFile: function(fileRecordA, fileRecordB) {\n\t\tvar errors = 0;\n\t\tvar leaveOutField = {\n      '_id': true,\n      'uploadDate': true,\n      'currentChunk': true,\n      'fileHandler': true\n    };\n\t\tfor (var fieldName in fileRecordA) {\n\t\t\tif (!leaveOutField[fieldName]) {\n\t\t\t\tif (fileRecordA[fieldName] !== fileRecordB[fieldName]) {\n\t\t\t\t\terrors++;\n\t\t\t\t\tconsole.log(fieldName);\n\t\t\t\t}\n\t\t\t}\n\t\t} //EO for\n\t\treturn (errors === 0);\n\t},\n\tmakeGridFSFileRecord: function(file, metadata) {\n\t\tvar self = this;\n\t\tvar countChunks = Math.ceil(file.size / self.chunkSize);\n\t\tvar userId = (Meteor.isClient)?\n\t\t\t\t\t\t( (this.userId) ? this.userId: Meteor.userId() ): file.owner;\n\t\tvar encoding = (file.encoding && file.encoding !== '') ?\n            file.encoding : 'utf-8';\n\n\t\treturn {\n      chunkSize : self.chunkSize,\t// Default 256kb ~ 262.144 bytes\n      uploadDate : Date.now(),\t\t// Client/Server set date\n      handledAt: null,            // datetime set by Server when handled\n      fileHandler: {},            // fileHandler supplied data if any\n      md5 : null,                 // Not yet implemented\n      complete : false,           // countChunks == numChunks\n      currentChunk: -1,           // Used to coordinate clients\n      owner: userId,\n      countChunks: countChunks,\t\t// Expected number of chunks\n      numChunks: 0,               // number of chunks in database\n      filename : file.name,       // Original filename\n      length: ''+file.size,       // Issue in Meteor, when solved dont use ''+\n      contentType : file.type,\n      encoding: encoding,\t\t\t// Default 'utf-8'\n      metadata : (metadata) ? metadata : null // Custom data\n      /* TODO:\n      startedAt: null,          // Start timer for upload start\n      endedAt: null,            // Stop timer for upload ended\n      */\n\t\t};\n\t\t// TODO: Implement md5 later, guess every chunk should have a md5...\n\t\t// TODO: checkup on gridFS date format\n\t} //EO makeGridFSFileRecord\n});\n","\"use strict\";\n\n/*\n  COMMON API\n\n  The fileObject is equal to the fileRecord + client-side api\n  This pattern will allow easier manipulation of files since we now pass\n  file objects with methods attatched.\n  In many cases we are only passed content objects with no reference to the\n  collection attached - This way we actually know were the data belongs and\n  makes operations much easier.\n\n*/\n_.extend(_fileObject.prototype, {\n  // Expect self to have the properties of fileRecord\n  // Added is self.collection for access to the collection the file belongs\n\n  // TODO: Add common file object api\n  remove: function() {\n    // TODO: Remove this file\n  },\n  getExtension: function() {\n    var extension;\n    // TODO: parse extension\n    return extension;\n  },\n  getUrl: function(filehandler) {\n    var filehandlerUrl;\n    // TODO: return url to filehandler\n    return filehandlerUrl;\n  }\n});","/*!\n * numeral.js\n * version : 1.4.9\n * author : Adam Draper\n * license : MIT\n * http://adamwdraper.github.com/Numeral-js/\n */\n\n(function() {\n\n    /************************************\n     Constants\n     ************************************/\n\n    var numeral,\n            VERSION = '1.4.9',\n            // internal storage for language config files\n            languages = {},\n            currentLanguage = 'en',\n            zeroFormat = null,\n            // check for nodeJS\n            hasModule = (typeof module !== 'undefined' && module.exports);\n\n\n    /************************************\n     Constructors\n     ************************************/\n\n\n    // Numeral prototype object\n    function Numeral(number) {\n        this._n = number;\n    }\n\n    /**\n     * Implementation of toFixed() that treats floats more like decimals\n     *\n     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n     * problems for accounting- and finance-related software.\n     */\n    function toFixed(value, precision, optionals) {\n        var power = Math.pow(10, precision),\n                output;\n\n        // Multiply up by precision, round accurately, then divide and use native toFixed():\n        output = (Math.round(value * power) / power).toFixed(precision);\n\n        if (optionals) {\n            var optionalsRegExp = new RegExp('0{1,' + optionals + '}$');\n            output = output.replace(optionalsRegExp, '');\n        }\n\n        return output;\n    }\n\n    /************************************\n     Formatting\n     ************************************/\n\n    // determine what type of formatting we need to do\n    function formatNumeral(n, format) {\n        var output;\n\n        // figure out what kind of format we are dealing with\n        if (format.indexOf('$') > -1) { // currency!!!!!\n            output = formatCurrency(n, format);\n        } else if (format.indexOf('%') > -1) { // percentage\n            output = formatPercentage(n, format);\n        } else if (format.indexOf(':') > -1) { // time\n            output = formatTime(n, format);\n        } else { // plain ol' numbers or bytes\n            output = formatNumber(n, format);\n        }\n\n        // return string\n        return output;\n    }\n\n    // revert to number\n    function unformatNumeral(n, string) {\n        if (string.indexOf(':') > -1) {\n            n._n = unformatTime(string);\n        } else {\n            if (string === zeroFormat) {\n                n._n = 0;\n            } else {\n                var stringOriginal = string;\n                if (languages[currentLanguage].delimiters.decimal !== '.') {\n                    string = string.replace(/\\./g, '').replace(languages[currentLanguage].delimiters.decimal, '.');\n                }\n\n                // see if abbreviations are there so that we can multiply to the correct number\n                var thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$'),\n                        millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$'),\n                        billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$'),\n                        trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$');\n\n                // see if bytes are there so that we can multiply to the correct number\n                var prefixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],\n                        bytesMultiplier = false;\n\n                for (var power = 0; power <= prefixes.length; power++) {\n                    bytesMultiplier = (string.indexOf(prefixes[power]) > -1) ? Math.pow(1024, power + 1) : false;\n\n                    if (bytesMultiplier) {\n                        break;\n                    }\n                }\n\n                // do some math to create our number\n                n._n = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * Number(((string.indexOf('(') > -1) ? '-' : '') + string.replace(/[^0-9\\.-]+/g, ''));\n\n                // round if we are talking about bytes\n                n._n = (bytesMultiplier) ? Math.ceil(n._n) : n._n;\n            }\n        }\n        return n._n;\n    }\n\n    function formatCurrency(n, format) {\n        var prependSymbol = (format.indexOf('$') <= 1) ? true : false;\n\n        // remove $ for the moment\n        var space = '';\n\n        // check for space before or after currency\n        if (format.indexOf(' $') > -1) {\n            space = ' ';\n            format = format.replace(' $', '');\n        } else if (format.indexOf('$ ') > -1) {\n            space = ' ';\n            format = format.replace('$ ', '');\n        } else {\n            format = format.replace('$', '');\n        }\n\n        // format the number\n        var output = formatNumeral(n, format);\n\n        // position the symbol\n        if (prependSymbol) {\n            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {\n                output = output.split('');\n                output.splice(1, 0, languages[currentLanguage].currency.symbol + space);\n                output = output.join('');\n            } else {\n                output = languages[currentLanguage].currency.symbol + space + output;\n            }\n        } else {\n            if (output.indexOf(')') > -1) {\n                output = output.split('');\n                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);\n                output = output.join('');\n            } else {\n                output = output + space + languages[currentLanguage].currency.symbol;\n            }\n        }\n\n        return output;\n    }\n\n    function formatPercentage(n, format) {\n        var space = '';\n        // check for space before %\n        if (format.indexOf(' %') > -1) {\n            space = ' ';\n            format = format.replace(' %', '');\n        } else {\n            format = format.replace('%', '');\n        }\n\n        n._n = n._n * 100;\n        var output = formatNumeral(n, format);\n        if (output.indexOf(')') > -1) {\n            output = output.split('');\n            output.splice(-1, 0, space + '%');\n            output = output.join('');\n        } else {\n            output = output + space + '%';\n        }\n        return output;\n    }\n\n    function formatTime(n, format) {\n        var hours = Math.floor(n._n / 60 / 60),\n                minutes = Math.floor((n._n - (hours * 60 * 60)) / 60),\n                seconds = Math.round(n._n - (hours * 60 * 60) - (minutes * 60));\n        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);\n    }\n\n    function unformatTime(string) {\n        var timeArray = string.split(':'),\n                seconds = 0;\n        // turn hours and minutes into seconds and add them all up\n        if (timeArray.length === 3) {\n            // hours\n            seconds = seconds + (Number(timeArray[0]) * 60 * 60);\n            // minutes\n            seconds = seconds + (Number(timeArray[1]) * 60);\n            // seconds\n            seconds = seconds + Number(timeArray[2]);\n        } else if (timeArray.length === 2) {\n            // minutes\n            seconds = seconds + (Number(timeArray[0]) * 60);\n            // seconds\n            seconds = seconds + Number(timeArray[1]);\n        }\n        return Number(seconds);\n    }\n\n    function formatNumber(n, format) {\n        var negP = false,\n                optDec = false,\n                abbr = '',\n                bytes = '',\n                ord = '',\n                abs = Math.abs(n._n);\n\n        // check if number is zero and a custom zero format has been set\n        if (n._n === 0 && zeroFormat !== null) {\n            return zeroFormat;\n        } else {\n            // see if we should use parentheses for negative number\n            if (format.indexOf('(') > -1) {\n                negP = true;\n                format = format.slice(1, -1);\n            }\n\n            // see if abbreviation is wanted\n            if (format.indexOf('a') > -1) {\n                // check for space before abbreviation\n                if (format.indexOf(' a') > -1) {\n                    abbr = ' ';\n                    format = format.replace(' a', '');\n                } else {\n                    format = format.replace('a', '');\n                }\n\n                if (abs >= Math.pow(10, 12)) {\n                    // trillion\n                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;\n                    n._n = n._n / Math.pow(10, 12);\n                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9)) {\n                    // billion\n                    abbr = abbr + languages[currentLanguage].abbreviations.billion;\n                    n._n = n._n / Math.pow(10, 9);\n                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6)) {\n                    // million\n                    abbr = abbr + languages[currentLanguage].abbreviations.million;\n                    n._n = n._n / Math.pow(10, 6);\n                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3)) {\n                    // thousand\n                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;\n                    n._n = n._n / Math.pow(10, 3);\n                }\n            }\n\n            // see if we are formatting bytes\n            if (format.indexOf('b') > -1) {\n                // check for space before\n                if (format.indexOf(' b') > -1) {\n                    bytes = ' ';\n                    format = format.replace(' b', '');\n                } else {\n                    format = format.replace('b', '');\n                }\n\n                var prefixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],\n                        min,\n                        max;\n\n                for (var power = 0; power <= prefixes.length; power++) {\n                    min = Math.pow(1024, power);\n                    max = Math.pow(1024, power + 1);\n\n                    if (n._n >= min && n._n < max) {\n                        bytes = bytes + prefixes[power];\n                        if (min > 0) {\n                            n._n = n._n / min;\n                        }\n                        break;\n                    }\n                }\n            }\n\n            // see if ordinal is wanted\n            if (format.indexOf('o') > -1) {\n                // check for space before\n                if (format.indexOf(' o') > -1) {\n                    ord = ' ';\n                    format = format.replace(' o', '');\n                } else {\n                    format = format.replace('o', '');\n                }\n\n                ord = ord + languages[currentLanguage].ordinal(n._n);\n            }\n\n            if (format.indexOf('[.]') > -1) {\n                optDec = true;\n                format = format.replace('[.]', '.');\n            }\n\n            var w = n._n.toString().split('.')[0],\n                    precision = format.split('.')[1],\n                    thousands = format.indexOf(','),\n                    d = '',\n                    neg = false;\n\n            if (precision) {\n                if (precision.indexOf('[') > -1) {\n                    precision = precision.replace(']', '');\n                    precision = precision.split('[');\n                    d = toFixed(n._n, (precision[0].length + precision[1].length), precision[1].length);\n                } else {\n                    d = toFixed(n._n, precision.length);\n                }\n\n                w = d.split('.')[0];\n\n                if (d.split('.')[1].length) {\n                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];\n                } else {\n                    d = '';\n                }\n\n                if (optDec && Number(d.slice(1)) === 0) {\n                    d = '';\n                }\n            } else {\n                w = toFixed(n._n, null);\n            }\n\n            // format number\n            if (w.indexOf('-') > -1) {\n                w = w.slice(1);\n                neg = true;\n            }\n\n            if (thousands > -1) {\n                w = w.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);\n            }\n\n            if (format.indexOf('.') === 0) {\n                w = '';\n            }\n\n            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');\n        }\n    }\n\n    /************************************\n     Top Level Functions\n     ************************************/\n\n    numeral = function(input) {\n        if (numeral.isNumeral(input)) {\n            input = input.value();\n        } else if (!Number(input)) {\n            input = 0;\n        }\n\n        return new Numeral(Number(input));\n    };\n\n    // version number\n    numeral.version = VERSION;\n\n    // compare numeral object\n    numeral.isNumeral = function(obj) {\n        return obj instanceof Numeral;\n    };\n\n    // This function will load languages and then set the global language.  If\n    // no arguments are passed in, it will simply return the current global\n    // language key.\n    numeral.language = function(key, values) {\n        if (!key) {\n            return currentLanguage;\n        }\n\n        if (key && !values) {\n            if (!languages[key]) {\n                throw new Error('Unknown language : ' + key);\n            }\n            currentLanguage = key;\n        }\n\n        if (values || !languages[key]) {\n            loadLanguage(key, values);\n        }\n\n        return numeral;\n    };\n\n    numeral.language('en', {\n        delimiters: {\n            thousands: ',',\n            decimal: '.'\n        },\n        abbreviations: {\n            thousand: 'k',\n            million: 'm',\n            billion: 'b',\n            trillion: 't'\n        },\n        ordinal: function(number) {\n            var b = number % 10;\n            return (~~(number % 100 / 10) === 1) ? 'th' :\n                    (b === 1) ? 'st' :\n                    (b === 2) ? 'nd' :\n                    (b === 3) ? 'rd' : 'th';\n        },\n        currency: {\n            symbol: '$'\n        }\n    });\n\n    numeral.zeroFormat = function(format) {\n        if (typeof(format) === 'string') {\n            zeroFormat = format;\n        } else {\n            zeroFormat = null;\n        }\n    };\n\n    /************************************\n     Helpers\n     ************************************/\n\n    function loadLanguage(key, values) {\n        languages[key] = values;\n    }\n\n\n    /************************************\n     Numeral Prototype\n     ************************************/\n\n\n    numeral.fn = Numeral.prototype = {\n        clone: function() {\n            return numeral(this);\n        },\n        format: function(inputString) {\n            return formatNumeral(this, inputString ? inputString : numeral.defaultFormat);\n        },\n        unformat: function(inputString) {\n            return unformatNumeral(this, inputString ? inputString : numeral.defaultFormat);\n        },\n        value: function() {\n            return this._n;\n        },\n        valueOf: function() {\n            return this._n;\n        },\n        set: function(value) {\n            this._n = Number(value);\n            return this;\n        },\n        add: function(value) {\n            this._n = this._n + Number(value);\n            return this;\n        },\n        subtract: function(value) {\n            this._n = this._n - Number(value);\n            return this;\n        },\n        multiply: function(value) {\n            this._n = this._n * Number(value);\n            return this;\n        },\n        divide: function(value) {\n            this._n = this._n / Number(value);\n            return this;\n        },\n        difference: function(value) {\n            var difference = this._n - Number(value);\n\n            if (difference < 0) {\n                difference = -difference;\n            }\n\n            return difference;\n        }\n\n    };\n\n    /************************************\n     Exposing Numeral\n     ************************************/\n\n    // CommonJS module is defined\n    if (hasModule) {\n        module.exports = numeral;\n    }\n\n    /*global ender:false */\n    if (typeof ender === 'undefined') {\n        // here, `this` means `window` in the browser, or `global` on the server\n        // add `numeral` as a global object via a string identifier,\n        // for Closure Compiler 'advanced' mode\n        this['numeral'] = numeral;\n    }\n\n    /*global define:false */\n    if (typeof define === 'function' && define.amd) {\n        define([], function() {\n            return numeral;\n        });\n    }\n}).call(this);"]}